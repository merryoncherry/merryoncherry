diff --git a/dependencies/log4cpp-codegit b/dependencies/log4cpp-codegit
--- a/dependencies/log4cpp-codegit
+++ b/dependencies/log4cpp-codegit
@@ -1 +1 @@
-Subproject commit 6448ecddc8d7fdf2179bbce574cec7341181295c
+Subproject commit 6448ecddc8d7fdf2179bbce574cec7341181295c-dirty
diff --git a/xLights/BitmapCache.cpp b/xLights/BitmapCache.cpp
index a58a68a30..567128793 100644
--- a/xLights/BitmapCache.cpp
+++ b/xLights/BitmapCache.cpp
@@ -601,7 +601,7 @@ wxBitmapBundle BitmapCache::GetModelGroupIcon() {
     return CreateBitmapBundleFromXPMs(16, "ModelGroup", {model_16, model_64, model_64, model_64, model_64});
 }
 wxBitmapBundle BitmapCache::GetFPPIcon() {
-    return wxBitmapBundle::FromSVG((const char*)fpp_app_icon_svg, wxSize(16, 16));
+    return wxBitmapBundle::FromSVG(fpp_app_icon_svg, sizeof(fpp_app_icon_svg), wxSize(16, 16));
 }
 
 const wxImage &BitmapCache::GetCornerIcon(int position, int size) {
diff --git a/xLights/RenderBuffer.cpp b/xLights/RenderBuffer.cpp
index 813dbc425..344a7c4e0 100644
--- a/xLights/RenderBuffer.cpp
+++ b/xLights/RenderBuffer.cpp
@@ -1255,6 +1255,153 @@ void RenderBuffer::DrawThickLine( const int x0_, const int y0_, const int x1_, c
   }
 }
 
+typedef std::pair<int, int> HLine;
+
+static void ScanEdge(int x1, int y1, int x2, int y2, int setx, bool skip, std::vector<HLine> &lines, int &eidx)
+{
+  int dx = x2 - x1;
+  int dy = y2 - y1;
+  if (dy <= 0)
+    return;
+  double invs = (double)dx / (double)dy;
+
+  int idx = eidx;
+
+  for (int y = y1 + (skip ? 1 : 0); y<y2; ++y, ++idx) {
+    if (setx)
+        lines[idx].first = x1 + (int)(ceil((y - y1) * invs));
+    else
+        lines[idx].second = x1 + (int)(ceil((y - y1) * invs));
+  }
+  eidx = idx;
+}
+
+void RenderBuffer::FillConvexPoly(const std::vector<std::pair<int, int>>& opoly, const xlColor& color)
+{
+    if (opoly.empty())
+        return;
+    std::vector<std::pair<int, int>> poly;
+    poly.push_back(opoly[0]);
+    for (size_t i = 1; i < opoly.size(); ++i) {
+        if (opoly[i] != opoly[i - 1]) {
+            poly.push_back(opoly[i]);
+        }
+    }
+    if (poly[0] == poly[poly.size() - 1]) {
+        poly.pop_back();
+    }
+
+    // Loosely based on Michael Abrash's Graphics Programming Black Book (TGPBB)
+    // Feels very low tech compared to what should be here, but high tech compared to the
+    //    rest of the stuff that actually is here (shrug)
+    if (poly.size() < 3)
+       return;
+    int miny, maxy, minx, maxx;
+    minx = maxx = poly[0].first;
+    miny = maxy = poly[0].second;
+    int minidxl = 0, maxidx = 0;
+
+    // Find the top and bottom
+    for (size_t i = 1; i < poly.size(); ++i) {
+        if (poly[i].second < miny) {
+            minidxl = i;
+            miny = poly[i].second;
+        }
+        if (poly[i].second > maxy) {
+            maxidx = i;
+            maxy = poly[i].second;
+        }
+        minx = std::min(minx, poly[i].first);
+        maxx = std::max(maxx, poly[i].first);
+    }
+
+    // Empty? Off Screen?
+    if (miny == maxy)
+       return;
+    if (minx >= this->BufferWi || maxx <= 0)
+        return;
+    if (miny >= this->BufferHt || maxy <= 0)
+       return;
+
+    int minidxr = minidxl;
+    while (poly[minidxr].second == miny)
+       minidxr = (minidxr + 1) % poly.size();
+    minidxr = (minidxr + poly.size() - 1) % poly.size();
+
+    while (poly[minidxl].second == miny)
+       minidxl = (minidxl + poly.size() - 1) % poly.size();
+    minidxl = (minidxl + 1) % poly.size();
+
+    int ledir = -1;
+    bool tif = (poly[minidxl].first != poly[minidxr].first);
+    if (tif) {
+       if (poly[minidxl].first > poly[minidxr].first) {
+            ledir = 1;
+            std::swap(minidxl, minidxr);
+       }
+    } else {
+       int nidx = minidxr;
+       nidx = (nidx + 1) % poly.size();
+       int pidx = minidxl;
+       pidx = (pidx + poly.size() - 1) % poly.size();
+       int dxn = poly[nidx].first - poly[minidxl].first;
+       int dyn = poly[nidx].second - poly[minidxl].second;
+       int dxp = poly[pidx].first - poly[minidxl].first;
+       int dyp = poly[pidx].second - poly[minidxl].second;
+       if (((long long)dxn * dyp - (long long)dyn * dxp) < 0L) {
+            ledir = 1;
+            std::swap(minidxl, minidxr);
+       }
+    }
+
+    int wheight = maxy - miny - 1 + (tif ? 1 : 0);
+    if (wheight <= 0)
+       return;
+    int ystart = miny + 1 - (tif ? 1 : 0);
+
+    std::vector<HLine> hlines(wheight);
+
+    int edgept = 0;
+    int cidx = minidxl, pidx = minidxl;
+    bool skip = tif ? 0 : 1;
+
+    /* Scan convert each line in the left edge from top to bottom */
+    do {
+       cidx = (cidx + poly.size() + ledir) % poly.size();
+       ScanEdge(poly[pidx].first, poly[pidx].second,
+                poly[cidx].first, poly[cidx].second,
+                true, skip, hlines, edgept);
+       pidx = cidx;
+       skip = false;
+    } while (cidx != maxidx);
+
+    edgept = 0;
+    pidx = cidx = minidxr;
+
+    skip = tif ? 0 : 1;
+    /* Scan convert the right edge, top to bottom. X coordinates are
+       adjusted 1 to the left, effectively causing scan conversion of
+       the nearest points to the left of but not exactly on the edge */
+    do {
+       cidx = (cidx + poly.size() - ledir) % poly.size();
+       ScanEdge(poly[pidx].first - 1, poly[pidx].second,
+                poly[cidx].first - 1, poly[cidx].second,
+                false, skip, hlines, edgept);
+       pidx = cidx;
+       skip = false;
+    } while (cidx != maxidx);
+
+    // Draw the line list representing the scan converted polygon
+    for (int y = ystart, en = 0; y < int(ystart + hlines.size()); ++y, ++en) {
+       if (y < 0 || y >= BufferHt)
+            continue;
+       int sx = std::max(0, hlines[en].first);
+       int ex = std::min(hlines[en].second, BufferWi - 1);
+       for (int x = sx; x <= ex; ++x)
+            SetPixel(x, y, color, false);
+    }
+}
+
 void RenderBuffer::DrawFadingCircle(int x0, int y0, int radius, const xlColor& rgb, bool wrap)
 {
     HSVValue hsv(rgb);
diff --git a/xLights/RenderBuffer.h b/xLights/RenderBuffer.h
index 2573181ba..f54bae428 100644
--- a/xLights/RenderBuffer.h
+++ b/xLights/RenderBuffer.h
@@ -212,6 +212,11 @@ public:
         return std::max(1, (int)color.size());
     }
 
+    size_t ExplicitSize() const
+    {
+        return color.size();
+    }
+
     const ColorCurve& GetColorCurve(size_t idx) const
     {
         if (idx >= cc.size()) {
@@ -492,6 +497,8 @@ public:
     void DrawThickLine(const int x1_, const int y1_, const int x2_, const int y2_, const xlColor& color, int thickness, bool useAlpha = false);
     void DrawThickLine(const int x1_, const int y1_, const int x2_, const int y2_, const xlColor& color, bool direction);
 
+    void FillConvexPoly(const std::vector<std::pair<int, int>>& poly, const xlColor& color);
+
     //approximation of sin/cos, but much faster
     static float sin(float rad);
     static float cos(float rad);
diff --git a/xLights/Xlights.vcxproj b/xLights/Xlights.vcxproj
index 1e52ac8df..dfc9e7a62 100644
--- a/xLights/Xlights.vcxproj
+++ b/xLights/Xlights.vcxproj
@@ -53,6 +53,7 @@
     <PreferredToolArchitecture>x64</PreferredToolArchitecture>
     <DefineConstants>
     </DefineConstants>
+    <EnableASAN>true</EnableASAN>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
diff --git a/xLights/effects/RippleEffect.cpp b/xLights/effects/RippleEffect.cpp
index 6b43f138d..253d95d96 100644
--- a/xLights/effects/RippleEffect.cpp
+++ b/xLights/effects/RippleEffect.cpp
@@ -14,7 +14,11 @@
 #include "../sequencer/Effect.h"
 #include "../RenderBuffer.h"
 #include "../UtilClasses.h"
+#include "../ExternalHooks.h"
+#include "../models/Model.h"
+#include "../xLightsMain.h"
 
+#include "nanosvg/src/nanosvg.h"
 
 #include "../../include/ripple-16.xpm"
 #include "../../include/ripple-24.xpm"
@@ -46,9 +50,11 @@ xlEffectPanel *RippleEffect::CreatePanel(wxWindow *parent) {
 #define RENDER_RIPPLE_SNOWFLAKE  8
 #define RENDER_RIPPLE_CRUCIFIX   9
 #define RENDER_RIPPLE_PRESENT    10
+#define RENDER_RIPPLE_SVG        11
 
 #define MOVEMENT_EXPLODE    0
 #define MOVEMENT_IMPLODE    1
+#define MOVEMENT_NONE       2
 
 void RippleEffect::SetDefaultParameters()
 {
@@ -60,6 +66,15 @@ void RippleEffect::SetDefaultParameters()
     rp->BitmapButton_Ripple_CyclesVC->SetActive(false);
     rp->BitmapButton_Ripple_ThicknessVC->SetActive(false);
     rp->BitmapButton_Ripple_RotationVC->SetActive(false);
+    rp->BitmapButton_Ripple_XCVC->SetActive(false);
+    rp->BitmapButton_Ripple_YCVC->SetActive(false);
+
+    rp->BitmapButton_Ripple_SpacingVC->SetActive(false);
+    rp->BitmapButton_Ripple_ScaleVC->SetActive(false);
+    rp->BitmapButton_Ripple_TwistVC->SetActive(false);
+    rp->BitmapButton_Ripple_VelocityVC->SetActive(false);
+    rp->BitmapButton_Ripple_DirectionVC->SetActive(false);
+    rp->BitmapButton_Ripple_OutlineVC->SetActive(false);
 
     SetChoiceValue(rp->Choice_Ripple_Object_To_Draw, "Circle");
     SetChoiceValue(rp->Choice_Ripple_Movement, "Explode");
@@ -69,49 +84,994 @@ void RippleEffect::SetDefaultParameters()
     SetSliderValue(rp->Slider_Ripple_Points, 5);
     SetSliderValue(rp->Slider_Ripple_Rotation, 0);
 
+    SetSliderValue(rp->Slider_Ripple_Scale, 100);
+    SetSliderValue(rp->Slider_Ripple_Direction, 0);
+    SetSliderValue(rp->Slider_Ripple_Velocity, 0);
+    SetSliderValue(rp->Slider_Ripple_Twist, 0);
+    SetSliderValue(rp->Slider_Ripple_Spacing, 10);
+    SetSliderValue(rp->Slider_Ripple_Outline, 10);
+
+    rp->FilePickerCtrl_SVG->SetFileName(wxFileName(""));
+
     SetCheckBoxValue(rp->CheckBox_Ripple3D, false);
+    SetChoiceValue(rp->Choice_Ripple_Draw_Style, "Old");
+}
+
+typedef std::pair<double, double> dpoint;
+typedef std::pair<int, int> ipoint;
+typedef std::vector<dpoint> dpointvec;
+typedef std::vector<ipoint> ipointvec;
+
+// It is somewhat redundant with 3-sided polygon isn't it?
+//  Especially now that it is equilateral
+static void getTrianglePoints(dpointvec& tpts)
+{
+    tpts.resize(3);
+#define ROOT3DIV3 0.577350269
+#define SIN30 0.5
+#define COS30 0.866025404
+
+    tpts[0] = { 0, 1 };
+    tpts[1] = { -COS30, -SIN30 };
+    tpts[2] = { COS30, -SIN30 };
+}
+
+// Now see, the square becomes a rectangle later, if desired
+// It is somewhat redundant with 4-side polygon isn't it...
+static void getSquarePoints(dpointvec& spts)
+{
+    spts.resize(4);
+    spts[0] = { 1, 1 };
+    spts[1] = { 1, -1 };
+    spts[2] = { -1, -1 };
+    spts[3] = { -1, 1 };
+}
+
+// Get polygon points; someone else applies that
+static void getPolygonPoints(dpointvec& ppts, int points)
+{
+    double rotation = 0;
+    if (points % 2 != 0)
+        rotation += 90;
+    if (points == 4)
+        rotation += 45;
+    if (points == 8)
+        rotation += 22.5;
+
+    double increment = 360.0 / points;
+    ppts.resize(points);
+
+    for (int i = 0; i < points; ++i, rotation += increment) {
+        double radian = (rotation)*M_PI / 180.0;
+        ppts[i] = { cos(radian), sin(radian) };
+    }
+}
+
+// OK can we just admit it is a polygon with a lot of points?
+static void getCirclePoints(dpointvec& ppts)
+{
+    getPolygonPoints(ppts, 100);
+}
+
+static void getCrossPoints(dpointvec& ppts)
+{
+    const wxPoint points[] = { wxPoint(2, 0),
+                               wxPoint(2, 6),
+                               wxPoint(0, 6),
+                               wxPoint(0, 7),
+                               wxPoint(2, 7),
+                               wxPoint(2, 10),
+                               wxPoint(3, 10),
+                               wxPoint(3, 7),
+                               wxPoint(5, 7),
+                               wxPoint(5, 6),
+                               wxPoint(3, 6),
+                               wxPoint(3, 0) };
+    ppts.clear();
+    for (const auto& pt : points) {
+        ppts.push_back({ (pt.x - 2.5) / 7.0, (pt.y - 6.5) / 10 });
+    }
+}
+
+static void getTreePoints(dpointvec& ppts)
+{
+    const wxPoint points[] = {
+        wxPoint(3, 3),
+        wxPoint(3, 0),
+        wxPoint(5, 0),
+        wxPoint(5, 3),
+        wxPoint(0, 3),
+        wxPoint(2, 6),
+        wxPoint(1, 6),
+        wxPoint(3, 9),
+        wxPoint(2, 9),
+        wxPoint(4, 11),
+        wxPoint(6, 9),
+        wxPoint(5, 9),
+        wxPoint(7, 6),
+        wxPoint(6, 6),
+        wxPoint(8, 3)
+    };
+    ppts.clear();
+    for (const auto& pt : points) {
+        ppts.push_back({ (pt.x - 4.0) / 11.0, (pt.y - 5.5) / 11.0 });
+    }
+}
+
+static void getPresentPoints(dpointvec& ppts)
+{
+    const wxPoint points[] = {
+        wxPoint(5, 9),
+        wxPoint(2, 11),
+        wxPoint(2, 9),
+        wxPoint(5, 9),
+        wxPoint(8, 11),
+        wxPoint(8, 9),
+        wxPoint(5, 9),
+        wxPoint(0, 9),
+        wxPoint(0, 0),
+        wxPoint(10, 0),
+        wxPoint(10, 9),
+        wxPoint(5, 9),
+        wxPoint(5, 0)
+    };
+
+    for (const auto& pt : points) {
+        ppts.push_back({ (pt.x - 5.0) / 7.0, (pt.y - 5.5) / 10.0 });
+    }
+}
+
+static void getHeartPoints(dpointvec& pts)
+{
+    dpointvec rpts;
+
+    double xincr = 1.0 / 64.0;
+    for (double x = -2.0; x <= 2.0; x += xincr) {
+        double y1 = std::sqrt(1.0 - (std::abs(x) - 1.0) * (std::abs(x) - 1.0));
+        double y2 = std::acos(1.0 - std::abs(x)) - M_PI;
+
+        double xx1 = x / 2.0;
+        double yy1 = y1 / 2.0;
+        double yy2 = y2 / 2.0;
+
+        pts.push_back({ xx1, yy1+.2 });
+        rpts.push_back({ xx1, yy2+.2 });
+    }
+
+    while (!rpts.empty()) {
+        pts.push_back(rpts.back());
+        rpts.pop_back();
+    }
+}
+
+static void getCanePoints(dpointvec& pts)
+{
+    // the stick
+    double ys1 = 1.0 / 3;
+    double ys2 = -2.0 / 3;
+    double xs = 1.0 / 3;
+    pts.clear();
+    pts.push_back({ xs, ys2 });
+    pts.push_back({ xs, ys1 });
+
+    // The hook
+    for (double degrees = 0.0; degrees < 180; degrees += 1.0) {
+        double radian = degrees * (M_PI / 180.0);
+        pts.push_back({ cos(radian) / 3, sin(radian) / 3 + ys1 });
+    }
+}
+
+static void getStarPoints(dpointvec& pts, int npts)
+{
+    double offsetangle = 90 - 360 / npts; // May as well be 90.  We just want a point that is up.
+
+    double InnerRadius = 1.0 / 2.618034; // divide by golden ratio squared
+
+    double increment = 360.0 / npts;
+
+    double deg = offsetangle;
+    for (int i = 0; i < npts; deg += increment, ++i) {
+        double radian = (deg) * (M_PI / 180.0);
+        double xouter = cos(radian);
+        double youter = sin(radian);
+
+        radian = (deg + increment / 2.0) * (M_PI / 180.0);
+        double xinner = InnerRadius * cos(radian);
+        double yinner = InnerRadius * sin(radian);
+
+        pts.push_back({ xouter, youter });
+        pts.push_back({ xinner, yinner });
+    }
+}
+
+static void getSnowflakePoints(dpointvec& pts, int npts)
+{
+    // The original is not, really, all that good for our purpose as it has no width.  Considering what to do instead.
+    npts *= 2;
+
+    double increment = 360.0 / npts;
+    pts.resize(npts * 3);
+
+    double rotation = 0; // The original always has spoke horizontal, don't like it, set rotation to 90
+
+    for (int i = 0; i < npts; ++i, rotation += increment) {
+        double delta = increment / 20;
+        double inrad = .05;
+
+        double r1 = (rotation - delta) * M_PI / 180.0;
+        double r2 = (rotation + delta) * M_PI / 180.0;
+        double r3 = (rotation + increment / 2) * M_PI / 180.0;
+
+        pts[i * 3 + 0] = { cos(r1), sin(r1) };
+        pts[i * 3 + 1] = { cos(r2), sin(r2) };
+        pts[i * 3 + 2] = { inrad * cos(r3), inrad * sin(r3) };
+    }
+}
+
+struct RippleShape {
+    dpointvec points;
+    bool closedShape = false;
+    HSVValue defColor = xlWHITE;
+    RippleShape()
+    {}
+    RippleShape(const dpointvec& vec, bool closed) :
+        points(vec), closedShape(closed)
+    {}
+};
+struct RippleShapes {
+    std::vector<RippleShape> shapes;
+    RippleShapes()
+    {}
+    RippleShapes(const dpointvec& vec, bool closed)
+    {
+        shapes.push_back(RippleShape(vec, closed));
+    }
+};
+
+inline uint8_t GetSVGRed(uint32_t colour)
+{
+    return (colour);
+}
+
+inline uint8_t GetSVGGreen(uint32_t colour)
+{
+    return (colour >> 8);
+}
+
+inline uint8_t GetSVGBlue(uint32_t colour)
+{
+    return (colour >> 16);
+}
+
+inline uint8_t GetSVGAlpha(uint32_t colour)
+{
+    return (colour >> 24);
+}
+
+inline uint32_t GetSVGExAlpha(uint32_t colour)
+{
+    return (colour & 0xFFFFFF);
+}
+
+inline dpoint ScalePoint(double x, double y, double cx, double cy, double sf)
+{
+    return { (x - cx) * sf, (y - cy) * sf };
+}
+
+static bool areSame(double ax, double ay, double bx, double by, double eps)
+{
+    return (ax - bx) * (ax - bx) + (ay - by) * (ay - by) < eps * eps;
+}
+
+static bool areCollinear(double a_x, double a_y, double b_x, double b_y, double c_x, double c_y, double eps)
+{
+    // use cross product to determine if point are in a strait line
+    auto test = (b_x - a_x) * (c_y - a_y) - (b_y - a_y) * (c_x - a_x);
+    return std::abs(test) < eps;
+}
+
+static double getLength(double a_x, double a_y, double b_x, double b_y, double c_x, double c_y, double d_x, double d_y)
+{
+    double sl = sqrt((d_x - a_x) * (d_x - a_x) + (d_y - a_y) * (d_y - a_y));
+    double fl = sqrt((b_x - a_x) * (b_x - a_x) + (b_y - a_y) * (b_y - a_y)) +
+                sqrt((c_x - b_x) * (c_x - b_x) + (c_y - b_y) * (c_y - b_y)) +
+                sqrt((d_x - c_x) * (d_x - c_x) + (d_y - c_y) * (d_y - c_y));
+
+    return sl + (fl - sl) / 2; // Approximately
+}
+
+static void buildSVG(RippleShapes &shapes, NSVGimage *image)
+{
+    if (!image)
+        return;
+
+    shapes.shapes.clear();
+
+    auto max = std::max(image->height, image->width);
+    double sf = 2.0 / max;
+    double cx = image->width / 2.0;
+    double cy = image->height / 2.0;
+    double ih = image->height;
+
+    for (NSVGshape* shape = image->shapes; shape != nullptr; shape = shape->next) {
+        // We are not attempting to do a faithful rendition of the SVG file.
+        // We are only trying to use the general shape as an outline, but in the event of
+        //   no color information being provided, we are also going to try to sniff out
+        //   a default color also.
+        xlColor defColor = xlWHITE;
+
+        // Some ways to get very simple default colors
+        if (GetSVGExAlpha(shape->fill.color) != 0) {
+            if(shape->fill.type == 1)
+            {
+                defColor = xlColor(GetSVGRed(shape->fill.color), GetSVGGreen(shape->fill.color), GetSVGBlue(shape->fill.color));
+            }
+        }
+        if (shape->stroke.type == 1) {
+            defColor = xlColor(GetSVGRed(shape->stroke.color), GetSVGGreen(shape->stroke.color), GetSVGBlue(shape->stroke.color));
+        }
+
+        for (NSVGpath* path = shape->paths; path != nullptr; path = path->next) {
+            dpointvec pts;
+            bool closedShape = false;
+            xlColor sdefColor = defColor;
+
+            for (int i = 0; i < path->npts - 1; i += 3) {
+                float* p = &path->pts[i * 2];
+
+                dpoint start = ScalePoint(p[0], ih - p[1], cx, cy, sf);
+                dpoint cp1 =   ScalePoint(p[2], ih - p[3], cx, cy, sf);
+                dpoint cp2 =   ScalePoint(p[4], ih - p[5], cx, cy, sf);
+                dpoint end =   ScalePoint(p[6], ih - p[7], cx, cy, sf);
+                if (i == 0) 
+                    pts.push_back(start);
+
+                // Break up anything long and not straight
+                double seglen = getLength(start.first, start.second, cp1.first, cp1.second, cp2.first, cp2.second, end.first, end.second);
+                if (seglen > .001 &&
+                    (!areCollinear(start.first, start.second, cp1.first, cp1.second, end.first, end.second, .001) ||
+                     !areCollinear(start.first, start.second, cp2.first, cp2.second, end.first, end.second, .001)))
+                {
+                    int nBreaks = (seglen / .001);
+                    if (areSame(end.first, end.second, cp2.first, cp2.second, .0002)) {
+                        for (int i = 1; i <= nBreaks; ++i) {
+                            double t = double(i) / nBreaks + 1; // We hit end later
+                            // 1(1-t)^2 2(1-t)t 1(t^2)
+                            double px = (1 - t) * (1 - t) * start.first +
+                                        2.0 * t * (1 - t) * cp1.first +
+                                        t * t * end.first;
+                            double py = (1 - t) * (1 - t) * start.second +
+                                        2.0 * t * (1 - t) * cp1.second +
+                                        t * t * end.second;
+                            pts.push_back({ px, py });
+                        }
+                    } else {
+                        for (int sd = 1; sd <= nBreaks; ++sd) {
+                            double t = double(sd) / (nBreaks + 1.0); // We hit end later
+                            // 1(1-t)^3 3(1-t)^2t 3(1-t)t^2 1(t^3)
+                            double px = (1 - t) * (1 - t) * (1 - t) * start.first +
+                                        3.0 * t * (1 - t) * (1 - t) * cp1.first +
+                                        3.0 * t * t * (1 - t) * cp2.first +
+                                        t * t * t * end.first;
+                            double py = (1 - t) * (1 - t) * (1 - t) * start.second +
+                                        3.0 * t * (1 - t) * (1 - t) * cp1.second +
+                                        3.0 * t * t * (1 - t) * cp2.second +
+                                        t * t * t * end.second;
+                            pts.push_back({ px, py });
+                        }
+                    }
+                }
+                pts.push_back(end);
+
+            }
+            if (path->closed) {
+                closedShape = true;
+            }
+            RippleShape s(pts, closedShape);
+            s.defColor = sdefColor;
+            shapes.shapes.push_back(s);
+        }
+    }
+}
+
+static void DrawShape(RenderBuffer &buffer, ipointvec &points, const xlColor &color, bool close)
+{
+    if (points.empty())
+        return;
+    for (size_t i = 0; i < points.size() - 1; ++i) {
+        buffer.DrawLine(points[i].first, points[i].second, points[i + 1].first, points[i + 1].second, color);
+    }
+    if (close) {
+        buffer.DrawLine(points[points.size() - 1].first, points[points.size() - 1].second, points[0].first, points[0].second, color);
+    }
+}
+
+static bool isConvex(const ipointvec& q)
+{
+    double cross = 0;
+    for (int i = 0; i < 4; i++) {
+        double x1 = q[(i + 1) % 4].first - q[i].first;
+        double y1 = q[(i + 1) % 4].second - q[i].second;
+        double x2 = q[(i + 2) % 4].first - q[(i + 1) % 4].first;
+        double y2 = q[(i + 2) % 4].second - q[(i + 1) % 4].second;
+        double cross_product = x1 * y2 - y1 * x2;
+
+        if (i == 0) {
+            cross = cross_product;
+        } else if (cross_product * cross <= 0) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static void FillSusQuad(RenderBuffer &buffer, const ipointvec& q, const xlColor &c)
+{
+    if (isConvex(q)) {
+        buffer.FillConvexPoly(q, c);
+        return;
+    }
+    // Hum the non-complex quad could be split in just the right place, which would be better.
+    ipointvec tri1 = { q[0], q[1], q[2] };
+    ipointvec tri2 = { q[0], q[1], q[3] };
+    ipointvec tri3 = { q[0], q[2], q[3] };
+    ipointvec tri4 = { q[1], q[2], q[3] };
+    buffer.FillConvexPoly(tri1, c);
+    buffer.FillConvexPoly(tri2, c);
+    buffer.FillConvexPoly(tri3, c);
+    buffer.FillConvexPoly(tri4, c);
+}
+
+static void DrawLine(RenderBuffer& buffer, const dpoint& p1, const dpoint& p2, const xlColor &c, bool thick = false)
+{
+    ipointvec q(4);
+    if (abs(p1.second - p2.second) > abs(p1.first - p2.first)) {
+        // More vertical travel
+        if (round(p1.first + .5) != round(p1.first)) {
+            q[0] = { round(p1.first), round(p1.second) };
+            q[1] = { round(p1.first) + 1, round(p1.second) };
+        } else {
+            q[0] = { round(p1.first) - 1, round(p1.second) };
+            q[1] = { round(p1.first), round(p1.second) };
+        }
+        if (round(p2.first + .5) != round(p2.first)) {
+            q[2] = { round(p2.first) + 1, round(p2.second) };
+            q[3] = { round(p2.first), round(p2.second) };
+        } else {
+            q[2] = { round(p2.first), round(p2.second) };
+            q[3] = { round(p2.first) - 1, round(p2.second) };
+        }
+    } else {
+        // More horizontal travel
+        if (round(p1.second + .5) != round(p1.second)) {
+            q[0] = { round(p1.first), round(p1.second) };
+            q[1] = { round(p1.first), round(p1.second) + 1 };
+        } else {
+            q[0] = { round(p1.first), round(p1.second) - 1};
+            q[1] = { round(p1.first), round(p1.second) };
+        }
+        if (round(p2.second + .5) != round(p2.second)) {
+            q[2] = { round(p2.first), round(p2.second) + 1 };
+            q[3] = { round(p2.first), round(p2.second) };
+        } else {
+            q[2] = { round(p2.first), round(p2.second) };
+            q[3] = { round(p2.first), round(p2.second) - 1 };
+        }
+    }
+    buffer.FillConvexPoly(q, c);
+    if (thick) {
+        buffer.SetPixel(round(p1.first), round(p1.second), c);
+        buffer.SetPixel(round(p2.first), round(p2.second), c);
+    }
+}
+
+static void DrawShapeD(RenderBuffer& buffer, dpointvec& points, const xlColor& color, bool close, bool thick)
+{
+    if (points.empty())
+        return;
+
+    for (size_t i = 0; i < points.size() - 1; ++i) {
+        DrawLine(buffer, { points[i].first, points[i].second }, { points[i + 1].first, points[i + 1].second }, color, thick);
+    }
+    if (close) {
+        DrawLine(buffer, { points[points.size() - 1].first, points[points.size() - 1].second }, { points[0].first, points[0].second }, color, thick);
+    }
 }
 
+static void FillRegion(RenderBuffer& buffer, ipointvec& oldpoints, const ipointvec& newpoints, const xlColor& color, bool close = true)
+{
+    if (oldpoints.empty())
+        return;
+    if (newpoints.size() != oldpoints.size())
+        return;
+
+    ipointvec quad(4);
+    for (size_t i = 0; i < newpoints.size() - 1; ++i) {
+        quad[0] = oldpoints[i];
+        quad[1] = oldpoints[i + 1];
+        quad[2] = newpoints[i + 1];
+        quad[3] = newpoints[i];
+
+        FillSusQuad(buffer, quad, color);
+    }
+
+    if (close) {
+        quad[0] = oldpoints[oldpoints.size() - 1];
+        quad[1] = oldpoints[0];
+        quad[2] = newpoints[0];
+        quad[3] = newpoints[oldpoints.size() - 1];
+
+        FillSusQuad(buffer, quad, color);
+    }
+}
+
+static ipointvec ScaleShape(const dpointvec& in, double sx, double sy, double cx, double cy, double rotation, bool round=false)
+{
+    ipointvec rv;
+    double angle_rad = rotation * M_PI / 180.0;
+
+    for (const auto& p : in) {
+        double x = p.first * sx;
+        double y = p.second * sy;
+        double rx = x * cos(angle_rad) - y * sin(angle_rad);
+        double ry = x * sin(angle_rad) + y * cos(angle_rad);
+
+        if (round) {
+            rv.push_back({ std::round(rx + cx), std::round(ry + cy) });
+        } else {
+            rv.push_back({ rx + cx, ry + cy });
+        }
+    }
+    return rv;
+}
+
+static dpointvec ScaleShapeD(const dpointvec& in, double sx, double sy, double cx, double cy, double rotation)
+{
+    dpointvec rv;
+    double angle_rad = rotation * M_PI / 180.0;
+
+    for (const auto& p : in) {
+        double x = p.first * sx;
+        double y = p.second * sy;
+        double rx = x * cos(angle_rad) - y * sin(angle_rad);
+        double ry = x * sin(angle_rad) + y * cos(angle_rad);
+
+        rv.push_back({ rx + cx, ry + cy });
+    }
+    return rv;
+}
+
+static void drawRippleNew(
+    RenderBuffer& buffer, const RippleShapes& shapes,
+    double time, double xcc, double ycc, double srotation, int mvmt, bool nonsquare,
+    int thickness, bool doInside, bool doOutside,
+    bool fade, bool lines, bool fill, bool ripple,
+    double scale, double outline, double spacing, double twist, double vel, double veldir)
+{
+    // Center point
+    double sxc = buffer.BufferWi / 2.0 + xcc * (buffer.BufferWi / 2.0) / 100.0;
+    double syc = buffer.BufferHt / 2.0 + ycc * (buffer.BufferHt / 2.0) / 100.0;
+
+    // Scaling for x and y directions - the original depended on whether it is on center...
+    //  and it isn't exactly true.  We may want a scale factor or something...
+    double maxRadius = 0.0;
+    double maxRadiusX = buffer.BufferWi / 2.0;
+    double maxRadiusY = buffer.BufferHt / 2.0;
+    if (buffer.BufferWi > buffer.BufferHt) {
+        maxRadius = maxRadiusX;
+    } else {
+        maxRadius = maxRadiusY;
+    }
+
+    // Everything is in percent - 1% is 1 pixel on a 100x100 matrix
+    //   We are using 1/10 pixel precision on the sliders, so this is a pixel on 1000.
+    //  Location things - x, y, are already percentages - that scales
+    //  Radius/scale is a percentage also
+    //  Rotation things are scale invariant (rotation, direction, twist)
+    //  Cycles is a temporal count, that's not related to scaling
+    //  Thickness is a number of ripples, that's invariant
+    //  Velocity may as well be in percent
+    //  The width of things is now also in percent, but we always draw a line so at least one pixel wide
+
+    // Color calculations TODO cut
+    size_t colorcnt = buffer.palette.ExplicitSize();
+    int cidxLines = 0;
+    if (colorcnt > 1) {
+        cidxLines = 1;
+    }
+    HSVValue lhsv;
+    buffer.palette.GetHSV(cidxLines, lhsv);
+    HSVValue fhsv = lhsv;
+    int cidxFill = cidxLines;
+    if (colorcnt > 2) {
+        buffer.palette.GetHSV(2, fhsv);
+        cidxFill = 2;
+    }
+
+    // Radius
+    double baseRadius = 1;
+    if (mvmt == MOVEMENT_EXPLODE)
+        baseRadius = time;
+    if (mvmt == MOVEMENT_IMPLODE)
+        baseRadius = 1 - time;
+    double brX = baseRadius * maxRadius;
+    double brY = baseRadius * maxRadius;
+    if (nonsquare) {
+        brX = baseRadius * maxRadiusX;
+        brY = baseRadius * maxRadiusY;
+    }
+    baseRadius *= scale;
+    brX *= scale;
+    brY *= scale;
+    vel *= maxRadius / 100; // vel was %
+    spacing *= maxRadius / 100; // Spacing in %
+    outline *= maxRadius / 100; // Outline in %
+
+    size_t nShapes = shapes.shapes.size();
+
+    // OK time to draw!
+    if (fill) {
+        std::vector<ipointvec> oldptsouter(nShapes), oldptsinner(nShapes);
+        std::vector<dpointvec> oldedgeouter(nShapes), oldedgeinner(nShapes);
+        for (int i = thickness; i >= 0; --i) {
+            double xc = sxc + (vel * sin(veldir / 180 * M_PI) * i);
+            double yc = syc - (vel * cos(veldir / 180 * M_PI) * i);
+            double rotation = srotation + twist * i;
+            double strength = (double(thickness) + 1 - i) / (thickness + 1); // Used for 3D/fade
+            double delta = ripple ? (i * (i + 1) * 0.25) : (i * 0.5);
+            delta *= spacing;
+
+            std::vector<dpointvec> nxtedgeouter(nShapes), nxtedgeinner(nShapes);
+            for (size_t sn = 0; sn < nShapes; ++sn) {
+                const dpointvec& points = shapes.shapes[sn].points;
+                bool closedShape = shapes.shapes[sn].closedShape;
+                xlColor fadeColor(fhsv);
+                if (cidxFill >= buffer.palette.ExplicitSize()) {
+                    fadeColor = shapes.shapes[sn].defColor;
+                } else {
+                    if (buffer.palette.IsSpatial(cidxFill)) {
+                        buffer.palette.GetSpatialColor(cidxFill, 0, 0, 0, i, 0, thickness, fadeColor);
+                    }
+                }
+
+                xlColor lineColor(lhsv);
+                if (cidxLines >= buffer.palette.ExplicitSize())
+                {
+                    lineColor = shapes.shapes[sn].defColor;
+                } else {
+                    if (buffer.palette.IsSpatial(cidxLines)) {
+                        buffer.palette.GetSpatialColor(cidxLines, 0, 0, 0, i, 0, thickness, lineColor);
+                    }
+                }
+
+                xlColor fadeColor3D = fadeColor;
+                if (buffer.allowAlpha) {
+                    fadeColor3D.alpha = 255.0 * strength;
+                } else {
+                    HSVValue hsvc = fadeColor;
+                    hsvc.value *= strength;
+                    fadeColor3D = hsvc;
+                }
+
+                if (doInside && brX - delta > 0 && brY - delta > 0) {
+                    ipointvec ishp = ScaleShape(points, brX - delta, brY - delta, xc, yc, rotation, true);
+                    if (!oldptsinner.empty()) {
+                        FillRegion(buffer, oldptsinner[sn], ishp, fade ? fadeColor3D : fadeColor, closedShape);
+                    }
+                    oldptsinner[sn] = ishp;
+                    if (lines) {
+                        nxtedgeinner[sn] = ScaleShapeD(points, brX - delta, brY - delta, xc, yc, rotation);
+                    }
+                } else if (doInside) {
+                    oldptsinner[sn] = ScaleShape(points, 0, 0, xc, yc, rotation, true);
+                }
+                if (doOutside && brX + delta > 0 && brY + delta > 0) {
+                    ipointvec oshp = ScaleShape(points, brX + delta, brY + delta, xc, yc, rotation, true);
+                    if (!oldptsouter[sn].empty()) {
+                        FillRegion(buffer, oldptsouter[sn], oshp, fade ? fadeColor3D : fadeColor, closedShape);
+                    }
+                    oldptsouter[sn] = oshp;
+                    if (lines) {
+                        nxtedgeouter[sn] = ScaleShapeD(points, brX + delta, brY + delta, xc, yc, rotation);
+                    }
+                }
+
+                if (oldedgeinner[sn].size()) {
+                    DrawShapeD(buffer, oldedgeinner[sn], lineColor, closedShape, false);
+                }
+                if (oldedgeouter[sn].size()) {
+                    DrawShapeD(buffer, oldedgeouter[sn], lineColor, closedShape, false);
+                }
+                
+                oldedgeouter[sn] = nxtedgeouter[sn];
+                oldedgeinner[sn] = nxtedgeinner[sn];
+            }
+        }
+
+        // Make sure no gaps between inside fill and outside, if both active
+        for (size_t sn = 0; sn < nShapes; ++sn) {
+            if (oldptsinner[sn].size() > 0 && oldptsouter[sn].size() > 0) {
+                bool closedShape = shapes.shapes[sn].closedShape;
+                xlColor fadeColor(fhsv);
+                if (cidxFill >= buffer.palette.ExplicitSize()) {
+                    fadeColor = shapes.shapes[sn].defColor;
+                } else {
+                    if (buffer.palette.IsSpatial(cidxFill)) {
+                        buffer.palette.GetSpatialColor(cidxFill, 0, 0, 0, 0, 0, thickness, fadeColor);
+                    }
+                }
+
+                FillRegion(buffer, oldptsinner[sn], oldptsouter[sn], fadeColor, closedShape);
+            }
+        }
+    }
+    if (lines && !fill) {
+        for (int i = thickness; i >= 0; --i) {
+            for (size_t sn = 0; sn < nShapes; ++sn) {
+                double xc = sxc + (vel * sin(veldir / 180 * M_PI) * i);
+                double yc = syc - (vel * cos(veldir / 180 * M_PI) * i);
+                double rotation = srotation + twist * i;
+                double strength = (double(thickness) + 1 - i) / (thickness + 1); // Used for 3D/fade
+                double delta = ripple ? (i * (i + 1) * 0.25) : (i * 0.5);
+                delta *= spacing;
+
+                xlColor lineColor(lhsv);
+                if (cidxLines >= buffer.palette.ExplicitSize()) {
+                    lineColor = shapes.shapes[sn].defColor;
+                } else {
+                    if (buffer.palette.IsSpatial(cidxLines)) {
+                        buffer.palette.GetSpatialColor(cidxLines, 0, 0, 0, i, 0, thickness, lineColor);
+                    }
+                }
+
+                xlColor fadeColor3D = lineColor;
+
+                if (buffer.allowAlpha) {
+                    fadeColor3D.alpha = 255.0 * strength;
+                } else {
+                    HSVValue hsvc = lineColor;
+                    hsvc.value *= strength;
+                    fadeColor3D = hsvc;
+                }
+
+                const dpointvec& points = shapes.shapes[sn].points;
+                bool closedShape = shapes.shapes[sn].closedShape;
+
+                if (doInside && brX - delta > 0 && brY - delta > 0) {
+                    ipointvec ishp = ScaleShape(points, brX - delta, brY - delta, xc, yc, rotation);
+                    DrawShape(buffer, ishp, (fade) ? fadeColor3D : lineColor, closedShape);
+                }
+                if (doOutside && brX + delta > 0 && brY + delta > 0) {
+                    ipointvec oshp = ScaleShape(points, brX + delta, brY + delta, xc, yc, rotation);
+                    DrawShape(buffer, oshp, (fade) ? fadeColor3D : lineColor, closedShape);
+                }
+            }
+        }
+    }
+
+    // Draw the main shape
+    for (size_t i = 0; i < shapes.shapes.size(); ++i) {
+        bool closedShape = shapes.shapes[i].closedShape;
+        const dpointvec& points = shapes.shapes[i].points;
+
+        int cidxShp = 0;
+        xlColor hsvs;
+        if (cidxShp < colorcnt) {
+            if (buffer.palette.IsSpatial(cidxShp)) {
+                buffer.palette.GetSpatialColor(cidxShp, 0, 0, 0, 0, 0, thickness, hsvs);
+            } else {
+                buffer.palette.GetColor(cidxShp, hsvs); // Now go and get the hsv value for this ColorIdx
+            }
+        } else {
+            hsvs = shapes.shapes[i].defColor;
+        }
+
+        if (brX+outline > 0 && brY+outline > 0) {
+            if (outline > 0) {
+                if (outline > 1) {
+                    // Asked for a thicker shape
+                    ipointvec inner = ScaleShape(points, std::max(brX - outline, 0.0), std::max(brY - outline, 0.0), sxc, syc, srotation, true);
+                    ipointvec outer = ScaleShape(points, std::max(brX + outline, 0.0), std::max(brY + outline, 0.0), sxc, syc, srotation, true);
+                    FillRegion(buffer, inner, outer, hsvs, closedShape);
+                }
+                // Default line drawn always
+                if (fill) {
+                    dpointvec mshp = ScaleShapeD(points, brX, brY, sxc, syc, srotation);
+                    DrawShapeD(buffer, mshp, hsvs, closedShape, true);
+                } else {
+                    ipointvec mshp = ScaleShape(points, brX, brY, sxc, syc, srotation);
+                    DrawShape(buffer, mshp, hsvs, closedShape);
+                }
+            }
+        }
+    }
+}
+
+class RippleRenderCache : public EffectRenderCache
+{
+public:
+    RippleRenderCache()
+    {
+    }
+    virtual ~RippleRenderCache()
+    {
+        if (_svgImage != nullptr) {
+            nsvgDelete(_svgImage);
+            _svgImage = nullptr;
+        }
+    }
+
+    NSVGimage* _svgImage = nullptr;
+    std::string _svgFilename;
+    double _svgScaleBase = 1.0f;
+
+    void InitialiseSVG(const std::string filename)
+    {
+        _svgFilename = filename;
+        _svgImage = nsvgParseFromFile(_svgFilename.c_str(), "px", 96);
+        if (_svgImage != nullptr) {
+            auto max = std::max(_svgImage->height, _svgImage->width);
+            _svgScaleBase = 1.0 / max;
+        }
+    }
+
+    NSVGimage* GetImage()
+    {
+        return _svgImage;
+    }
+};
+
+// TODO:
+// 4 ENH: There is the matter of colors (around; this is a matter of breaking long segments up)
+
 void RippleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBuffer& buffer)
 {
     float oset = buffer.GetEffectTimeIntervalPosition();
     const std::string& Object_To_DrawStr = SettingsMap["CHOICE_Ripple_Object_To_Draw"];
+    std::string svgFilename = SettingsMap["FILEPICKERCTRL_SVG"];
     const std::string& MovementStr = SettingsMap["CHOICE_Ripple_Movement"];
     int Ripple_Thickness = GetValueCurveInt("Ripple_Thickness", 3, SettingsMap, oset, RIPPLE_THICKNESS_MIN, RIPPLE_THICKNESS_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
     bool CheckBox_Ripple3D = SettingsMap.GetBool("CHECKBOX_Ripple3D", false);
-    float cycles = GetValueCurveDouble("Ripple_Cycles", 1.0, SettingsMap, oset, RIPPLE_CYCLES_MIN, RIPPLE_CYCLES_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), 10);
+    const std::string& StyleStr = SettingsMap.Get("CHOICE_Ripple_Draw_Style", "Old");
+    float cycles = GetValueCurveDouble("Ripple_Cycles", 1.0, SettingsMap, oset, RIPPLE_CYCLES_MIN, RIPPLE_CYCLES_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), RIPPLE_CYCLES_DIVISOR);
     int points = SettingsMap.GetInt("SLIDER_RIPPLE_POINTS", 5);
     int rotation = GetValueCurveInt("Ripple_Rotation", 0, SettingsMap, oset, RIPPLE_ROTATION_MIN, RIPPLE_ROTATION_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
     int xcc = GetValueCurveInt("Ripple_XC", 0, SettingsMap, oset, RIPPLE_XC_MIN, RIPPLE_XC_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
     int ycc = GetValueCurveInt("Ripple_YC", 0, SettingsMap, oset, RIPPLE_YC_MIN, RIPPLE_YC_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
+    double scale = GetValueCurveDouble("Ripple_Scale", 100, SettingsMap, oset, RIPPLE_SCALE_MIN, RIPPLE_SCALE_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS()) / 100.0;
+    double spacing = GetValueCurveDouble("Ripple_Spacing", 1.0, SettingsMap, oset, RIPPLE_SPACING_MIN, RIPPLE_SPACING_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), RIPPLE_SPACING_DIVISOR);
+    double outline = GetValueCurveDouble("Ripple_Outline", 1.0, SettingsMap, oset, RIPPLE_OUTLINE_MIN, RIPPLE_OUTLINE_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), RIPPLE_OUTLINE_DIVISOR);
+    double twist = GetValueCurveDouble("Ripple_Twist", 0, SettingsMap, oset, RIPPLE_TWIST_MIN, RIPPLE_TWIST_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), RIPPLE_TWIST_DIVISOR);
+    double vel = GetValueCurveDouble("Ripple_Velocity", 0, SettingsMap, oset, RIPPLE_VELOCITY_MIN, RIPPLE_VELOCITY_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS(), RIPPLE_VELOCITY_DIVISOR);
+    double veldir = GetValueCurveDouble("Ripple_Direction", 0, SettingsMap, oset, RIPPLE_DIRECTION_MIN, RIPPLE_DIRECTION_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
+
+    RippleRenderCache* cache = (RippleRenderCache*)buffer.infoCache[id];
+    if (cache == nullptr) {
+        cache = new RippleRenderCache();
+        buffer.infoCache[id] = cache;
+    }
+
+    double position = buffer.GetEffectTimeIntervalPosition(cycles); // how far are we into the effect; value is 0.0 to 1.0
 
     int Object_To_Draw;
-    if (Object_To_DrawStr == "Circle") {
+    dpointvec shapePts;
+    bool closeShape = true;
+    bool uniformAspectRatio = true;
+
+    RippleShapes shapes;
+
+    if (Object_To_DrawStr == "SVG" && StyleStr != "Old") {
+        Object_To_Draw = RENDER_RIPPLE_SVG;
+        getCirclePoints(shapePts); // In case of invalid SVG
+    } else if (Object_To_DrawStr == "Circle") {
+        getCirclePoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_CIRCLE;
     } else if (Object_To_DrawStr == "Square") {
+        getSquarePoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_SQUARE;
+        uniformAspectRatio = false; // This is actually a rectangle
     } else if (Object_To_DrawStr == "Triangle") {
+        getTrianglePoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_TRIANGLE;
     } else if (Object_To_DrawStr == "Star") {
+        getStarPoints(shapePts, points);
         Object_To_Draw = RENDER_RIPPLE_STAR;
     } else if (Object_To_DrawStr == "Polygon") {
+        getPolygonPoints(shapePts, points);
         Object_To_Draw = RENDER_RIPPLE_POLYGON;
     } else if (Object_To_DrawStr == "Heart") {
+        getHeartPoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_HEART;
     } else if (Object_To_DrawStr == "Tree") {
+        getTreePoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_TREE;
     } else if (Object_To_DrawStr == "Candy Cane") {
+        getCanePoints(shapePts);
+        closeShape = false;
         Object_To_Draw = RENDER_RIPPLE_CANDYCANE;
     } else if (Object_To_DrawStr == "Snow Flake") {
+        getSnowflakePoints(shapePts, points);
         Object_To_Draw = RENDER_RIPPLE_SNOWFLAKE;
     } else if (Object_To_DrawStr == "Crucifix") {
         Object_To_Draw = RENDER_RIPPLE_CRUCIFIX;
+        getCrossPoints(shapePts);
     } else if (Object_To_DrawStr == "Present") {
+        getPresentPoints(shapePts);
+        closeShape = false;
         Object_To_Draw = RENDER_RIPPLE_PRESENT;
     } else {
+        getCirclePoints(shapePts);
         Object_To_Draw = RENDER_RIPPLE_CIRCLE;
     }
-    int Movement = "Explode" == MovementStr ? MOVEMENT_EXPLODE : MOVEMENT_IMPLODE;
+    if (shapes.shapes.empty()) {
+        // Build from shapePts, closed
+        shapes = RippleShapes(shapePts, closeShape);
+    }
+
+    int Movement = MOVEMENT_NONE;
+    if (MovementStr == "Explode") {
+        Movement = MOVEMENT_EXPLODE;
+    }
+    if (MovementStr == "Implode") {
+        Movement = MOVEMENT_IMPLODE;
+    }
+
+    bool drawNew = false;
+    bool interiorDirection = false;
+    bool exteriorDirection = false;
+    bool drawFill = false;
+    bool drawLines = false;
+    bool rippleSpaced = false;
+
+    auto swords = wxSplit(StyleStr, ' ');
+    if (swords.size() > 1) {
+        drawNew = true;
+        if (swords[0] == "Lines") {
+            drawLines = true;
+        }
+        if (swords[0] == "Solid") {
+            drawFill = true;
+        }
+        if (swords[0] == "Highlight") {
+            drawFill = true;
+            drawLines = true;
+        }
+        if (swords[1] == "Inward") {
+            interiorDirection = true;
+        }
+        if (swords[1] == "Outward") {
+            exteriorDirection = true;
+        }
+        if (swords[1] == "Both") {
+            interiorDirection = true;
+            exteriorDirection = true;
+        }
+        if (swords.size() > 2) {
+            // Assume it says "Ripple"
+            rippleSpaced = true;
+        }
+    }
+
+    if (buffer.needToInit) {
+        buffer.needToInit = false;
+
+        if (Object_To_Draw == RENDER_RIPPLE_SVG) {
+            cache->InitialiseSVG(svgFilename);
+        }
+    }
+
+    if (Object_To_Draw == RENDER_RIPPLE_SVG) {
+        buildSVG(shapes, cache->GetImage());
+    }
+
+    if (drawNew)
+    {
+        drawRippleNew(buffer, shapes, position, xcc, ycc, rotation, Movement,
+                      !uniformAspectRatio, Ripple_Thickness, interiorDirection, exteriorDirection,
+                 CheckBox_Ripple3D, drawLines, drawFill, rippleSpaced, scale, outline, spacing, twist, vel, veldir);
+        return;
+    }
 
     int ColorIdx;
     int xc, yc;
@@ -119,8 +1079,6 @@ void RippleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
     HSVValue hsv;
     size_t colorcnt = buffer.GetColorCount();
 
-    double position = buffer.GetEffectTimeIntervalPosition(cycles); // how far are we into the row> value is 0.0 to 1.0
-
     float rx = position;
     xc = buffer.BufferWi / 2 + xcc * (buffer.BufferWi / 2) / 100;
     yc = buffer.BufferHt / 2 + ycc * (buffer.BufferHt / 2) / 100;
@@ -154,6 +1112,7 @@ void RippleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
     }
 
     buffer.palette.GetHSV(ColorIdx, hsv); // Now go and get the hsv value for this ColorIdx
+
     switch (Object_To_Draw) {
     case RENDER_RIPPLE_SQUARE: {
         int x1 = xc - radiusX;
@@ -205,10 +1164,6 @@ void RippleEffect::Drawtriangle(RenderBuffer& buffer, int Movement, int xc, int
 
     xlColor color(hsv);
 
-#define ROOT3DIV3 0.577350269
-#define SIN30 0.5
-#define COS30 0.866025404
-
     for (int i = 0; i < Ripple_Thickness; i++) {
         double radius = (side + i) * ROOT3DIV3;
         double ytop = yc + radius;
@@ -217,7 +1172,7 @@ void RippleEffect::Drawtriangle(RenderBuffer& buffer, int Movement, int xc, int
         double xleft = xc - radius * COS30;
         double yleft = yc - radius * SIN30;
 
-        double xright = xleft + side + i;
+        double xright = xleft + side + i; // This is kinda weird
         double yright = yleft;
 
         if (CheckBox_Ripple3D) {
@@ -228,6 +1183,7 @@ void RippleEffect::Drawtriangle(RenderBuffer& buffer, int Movement, int xc, int
                 color = hsv;
             }
         }
+
         buffer.DrawLine(xtop, ytop, xleft, yleft, color);
         buffer.DrawLine(xtop, ytop, xright, yright, color);
         buffer.DrawLine(xleft, yleft, xright, yright, color);
@@ -384,6 +1340,8 @@ void RippleEffect::Drawpolygon(RenderBuffer& buffer, int Movement, int xc, int y
 
     xlColor color(hsv);
 
+    std::vector<std::pair<int, int>> oldpts, newpts;
+
     for (double i = 0; i < Ripple_Thickness; i += .5) {
         if (CheckBox_Ripple3D) {
             if (buffer.allowAlpha) {
@@ -713,3 +1671,45 @@ void RippleEffect::Drawcandycane(RenderBuffer& buffer, int Movement, int xc, int
     }
 }
 
+std::list<std::string> RippleEffect::GetFileReferences(Model* model, const SettingsMap& SettingsMap) const
+{
+    std::list<std::string> res;
+    if (SettingsMap["E_FILEPICKERCTRL_SVG"] != "") {
+        res.push_back(SettingsMap["E_FILEPICKERCTRL_SVG"]);
+    }
+    return res;
+}
+
+std::list<std::string> RippleEffect::CheckEffectSettings(const SettingsMap& settings, AudioManager* media, Model* model, Effect* eff, bool renderCache)
+{
+    std::list<std::string> res;
+
+    std::string object = settings["E_CHOICE_Ripple_Object_To_Draw"];
+    if (object == "SVG") {
+        auto svgFilename = settings.Get("E_FILEPICKERCTRL_SVG", "");
+
+        if (svgFilename == "" || !FileExists(svgFilename)) {
+            res.push_back(wxString::Format("    ERR: Ripple effect can't find SVG file '%s'. Model '%s', Start %s", svgFilename, model->GetName(), FORMATTIME(eff->GetStartTimeMS())).ToStdString());
+        } else {
+            if (!IsFileInShowDir(xLightsFrame::CurrentDir, svgFilename)) {
+                res.push_back(wxString::Format("    WARN: Ripple effect SVG file '%s' not under show directory. Model '%s', Start %s", svgFilename, model->GetName(), FORMATTIME(eff->GetStartTimeMS())).ToStdString());
+            }
+        }
+    }
+
+    return res;
+}
+
+bool RippleEffect::CleanupFileLocations(xLightsFrame* frame, SettingsMap& SettingsMap)
+{
+    bool rc = false;
+    wxString file = SettingsMap["E_FILEPICKERCTRL_SVG"];
+    if (FileExists(file)) {
+        if (!frame->IsInShowFolder(file)) {
+            SettingsMap["E_FILEPICKERCTRL_SVG"] = frame->MoveToShowFolder(file, wxString(wxFileName::GetPathSeparator()) + "Images");
+            rc = true;
+        }
+    }
+
+    return rc;
+}
\ No newline at end of file
diff --git a/xLights/effects/RippleEffect.h b/xLights/effects/RippleEffect.h
index 5bfb7a00e..beb0ddd3e 100644
--- a/xLights/effects/RippleEffect.h
+++ b/xLights/effects/RippleEffect.h
@@ -16,11 +16,12 @@
 
 #define RIPPLE_CYCLES_MIN 0
 #define RIPPLE_CYCLES_MAX 300
+#define RIPPLE_CYCLES_DIVISOR 10
 
 #define RIPPLE_THICKNESS_MIN 1
 #define RIPPLE_THICKNESS_MAX 100
 
-#define RIPPLE_ROTATION_MIN 0
+#define RIPPLE_ROTATION_MIN -360
 #define RIPPLE_ROTATION_MAX 360
 
 #define RIPPLE_XC_MIN -100
@@ -29,6 +30,28 @@
 #define RIPPLE_YC_MIN -100
 #define RIPPLE_YC_MAX 100
 
+#define RIPPLE_SPACING_MIN 1
+#define RIPPLE_SPACING_MAX 400
+#define RIPPLE_SPACING_DIVISOR 10
+
+#define RIPPLE_SCALE_MIN 0
+#define RIPPLE_SCALE_MAX 500
+
+#define RIPPLE_VELOCITY_MIN 0
+#define RIPPLE_VELOCITY_MAX 300
+#define RIPPLE_VELOCITY_DIVISOR 10
+
+#define RIPPLE_DIRECTION_MIN -360
+#define RIPPLE_DIRECTION_MAX 360
+
+#define RIPPLE_TWIST_MIN -450
+#define RIPPLE_TWIST_MAX 450
+#define RIPPLE_TWIST_DIVISOR 10
+
+#define RIPPLE_OUTLINE_MIN 0
+#define RIPPLE_OUTLINE_MAX 100
+#define RIPPLE_OUTLINE_DIVISOR 10
+
 class RippleEffect : public RenderableEffect
 {
 public:
@@ -36,15 +59,32 @@ public:
     virtual ~RippleEffect();
     virtual void SetDefaultParameters() override;
     virtual void Render(Effect* effect, const SettingsMap& settings, RenderBuffer& buffer) override;
+    //virtual void SetPanelStatus(Model* cls) override;
+    //virtual void RenameTimingTrack(std::string oldname, std::string newname, Effect* effect) override;
     virtual bool AppropriateOnNodes() const override
     {
         return false;
     }
+    virtual bool SupportsRenderCache(const SettingsMap& settings) const override
+    {
+        return true;
+    }
+    virtual std::list<std::string> GetFileReferences(Model* model, const SettingsMap& SettingsMap) const override;
+    virtual bool CleanupFileLocations(xLightsFrame* frame, SettingsMap& SettingsMap) override;
+    virtual std::list<std::string> CheckEffectSettings(const SettingsMap& settings, AudioManager* media, Model* model, Effect* eff, bool renderCache) override;
     virtual bool CanRenderPartialTimeInterval() const override
     {
         return true;
     }
 
+    virtual bool SupportsRadialColorCurves(const SettingsMap& SettingsMap) const
+    {
+        return true;
+        // Not sure this updates dynamically as one would want
+        //std::string ds = SettingsMap.Get("CHOICE_Ripple_Draw_Style", "Old");
+        //return ds != "Old";
+    }
+
     virtual double GetSettingVCMin(const std::string& name) const override
     {
         if (name == "E_VALUECURVE_Ripple_Cycles")
@@ -57,6 +97,18 @@ public:
             return RIPPLE_XC_MIN;
         if (name == "E_VALUECURVE_Ripple_YC")
             return RIPPLE_YC_MIN;
+        if (name == "E_VALUECURVE_Ripple_Spacing")
+            return RIPPLE_SPACING_MIN;
+        if (name == "E_VALUECURVE_Ripple_Scale")
+            return RIPPLE_SCALE_MIN;
+        if (name == "E_VALUECURVE_Ripple_Velocity")
+            return RIPPLE_VELOCITY_MIN;
+        if (name == "E_VALUECURVE_Ripple_Direction")
+            return RIPPLE_DIRECTION_MIN;
+        if (name == "E_VALUECURVE_Ripple_Twist")
+            return RIPPLE_TWIST_MIN;
+        if (name == "E_VALUECURVE_Ripple_Outline")
+            return RIPPLE_OUTLINE_MIN;
         return RenderableEffect::GetSettingVCMin(name);
     }
 
@@ -72,18 +124,46 @@ public:
             return RIPPLE_XC_MAX;
         if (name == "E_VALUECURVE_Ripple_YC")
             return RIPPLE_YC_MAX;
+        if (name == "E_VALUECURVE_Ripple_Spacing")
+            return RIPPLE_SPACING_MAX;
+        if (name == "E_VALUECURVE_Ripple_Scale")
+            return RIPPLE_SCALE_MAX;
+        if (name == "E_VALUECURVE_Ripple_Velocity")
+            return RIPPLE_VELOCITY_MAX;
+        if (name == "E_VALUECURVE_Ripple_Direction")
+            return RIPPLE_DIRECTION_MAX;
+        if (name == "E_VALUECURVE_Ripple_Twist")
+            return RIPPLE_TWIST_MAX;
+        if (name == "E_VALUECURVE_Ripple_Outline")
+            return RIPPLE_OUTLINE_MAX;
         return RenderableEffect::GetSettingVCMax(name);
     }
 
+    virtual int GetSettingVCDivisor(const std::string& name) const override
+    {
+        if (name == "E_VALUECURVE_Ripple_Cycles")
+            return RIPPLE_CYCLES_DIVISOR;
+        if (name == "E_VALUECURVE_Ripple_Spacing")
+            return RIPPLE_SPACING_DIVISOR;
+        if (name == "E_VALUECURVE_Ripple_Twist")
+            return RIPPLE_TWIST_DIVISOR;
+        if (name == "E_VALUECURVE_Ripple_Velocity")
+            return RIPPLE_VELOCITY_DIVISOR;
+        if (name == "E_VALUECURVE_Ripple_Outline")
+            return RIPPLE_OUTLINE_DIVISOR;
+        return RenderableEffect::GetSettingVCDivisor(name);
+    }
+
 protected:
     virtual xlEffectPanel* CreatePanel(wxWindow* parent) override;
 
 private:
+
+    // Old-style draw functions
     void Drawcircle(RenderBuffer& buffer, int Movement, int xc, int yc, double radius, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D);
     void Drawsquare(RenderBuffer& buffer, int Movement, int x1, int x2, int y1, int y2, int Ripple_Thickness, int CheckBox_Ripple3D, HSVValue& hsv);
     void Drawtriangle(RenderBuffer& buffer, int Movement, int xc, int yc, double side, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D);
     void Drawstar(RenderBuffer& buffer, int Movement, int xc, int yc, double radius, int points, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D, float rotation);
-
     void Drawheart(RenderBuffer& buffer, int Movement, int xc, int yc, double radius, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D);
     void Drawpolygon(RenderBuffer& buffer, int Movement, int xc, int yc, double radius, int points, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D, float rotation);
     void Drawsnowflake(RenderBuffer& buffer, int Movement, int xc, int yc, double radius, int points, HSVValue& hsv, int Ripple_Thickness, int CheckBox_Ripple3D, double rotation);
diff --git a/xLights/effects/RipplePanel.cpp b/xLights/effects/RipplePanel.cpp
index 189599267..267bdfdc6 100644
--- a/xLights/effects/RipplePanel.cpp
+++ b/xLights/effects/RipplePanel.cpp
@@ -17,6 +17,7 @@
 #include <wx/bmpbuttn.h>
 #include <wx/checkbox.h>
 #include <wx/choice.h>
+#include <wx/filepicker.h>
 #include <wx/image.h>
 #include <wx/intl.h>
 #include <wx/settings.h>
@@ -31,14 +32,29 @@
 const long RipplePanel::ID_STATICTEXT_Ripple_Object_To_Draw = wxNewId();
 const long RipplePanel::ID_CHOICE_Ripple_Object_To_Draw = wxNewId();
 const long RipplePanel::ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw = wxNewId();
+const long RipplePanel::ID_FILEPICKERCTRL_SVG = wxNewId();
 const long RipplePanel::ID_STATICTEXT_Ripple_Movement = wxNewId();
 const long RipplePanel::ID_CHOICE_Ripple_Movement = wxNewId();
 const long RipplePanel::ID_BITMAPBUTTON_CHOICE_Ripple_Movement = wxNewId();
+const long RipplePanel::ID_STATICTEXT6 = wxNewId();
+const long RipplePanel::ID_SLIDER_Ripple_Scale = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Scale = wxNewId();
+const long RipplePanel::IDD_TEXTCTRL_Ripple_Scale = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Scale = wxNewId();
+const long RipplePanel::IDD_SLIDER_Ripple_Outline = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Outline = wxNewId();
+const long RipplePanel::ID_TEXTCTRL_Ripple_Outline = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Outline = wxNewId();
 const long RipplePanel::ID_STATICTEXT_Ripple_Thickness = wxNewId();
 const long RipplePanel::ID_SLIDER_Ripple_Thickness = wxNewId();
 const long RipplePanel::ID_VALUECURVE_Ripple_Thickness = wxNewId();
 const long RipplePanel::IDD_TEXTCTRL_Ripple_Thickness = wxNewId();
 const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Thickness = wxNewId();
+const long RipplePanel::ID_STATICTEXT4 = wxNewId();
+const long RipplePanel::IDD_SLIDER_Ripple_Spacing = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Spacing = wxNewId();
+const long RipplePanel::ID_TEXTCTRL_Ripple_Spacing = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Spacing = wxNewId();
 const long RipplePanel::ID_STATICTEXT_Ripple_Cycles = wxNewId();
 const long RipplePanel::IDD_SLIDER_Ripple_Cycles = wxNewId();
 const long RipplePanel::ID_VALUECURVE_Ripple_Cycles = wxNewId();
@@ -52,6 +68,11 @@ const long RipplePanel::ID_SLIDER_Ripple_Rotation = wxNewId();
 const long RipplePanel::ID_VALUECURVE_Ripple_Rotation = wxNewId();
 const long RipplePanel::IDD_TEXTCTRL_Ripple_Rotation = wxNewId();
 const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Rotation = wxNewId();
+const long RipplePanel::ID_STATICTEXT5 = wxNewId();
+const long RipplePanel::IDD_SLIDER_Ripple_Twist = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Twist = wxNewId();
+const long RipplePanel::ID_TEXTCTRL_Ripple_Twist = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Twist = wxNewId();
 const long RipplePanel::ID_STATICTEXT2 = wxNewId();
 const long RipplePanel::ID_SLIDER_Ripple_XC = wxNewId();
 const long RipplePanel::ID_VALUECURVE_Ripple_XC = wxNewId();
@@ -60,6 +81,19 @@ const long RipplePanel::ID_STATICTEXT3 = wxNewId();
 const long RipplePanel::ID_SLIDER_Ripple_YC = wxNewId();
 const long RipplePanel::ID_VALUECURVE_Ripple_YC = wxNewId();
 const long RipplePanel::IDD_TEXTCTRL_Ripple_YC = wxNewId();
+const long RipplePanel::ID_STATICTEXT7 = wxNewId();
+const long RipplePanel::IDD_SLIDER_Ripple_Velocity = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Velocity = wxNewId();
+const long RipplePanel::ID_TEXTCTRL_Ripple_Velocity = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Velocity = wxNewId();
+const long RipplePanel::ID_STATICTEXT8 = wxNewId();
+const long RipplePanel::ID_SLIDER_Ripple_Direction = wxNewId();
+const long RipplePanel::ID_VALUECURVE_Ripple_Direction = wxNewId();
+const long RipplePanel::IDD_TEXTCTRL_Ripple_Direction = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_SLIDER_Ripple_Direction = wxNewId();
+const long RipplePanel::ID_STATICTEXT_Ripple_Draw_Style = wxNewId();
+const long RipplePanel::ID_CHOICE_Ripple_Draw_Style = wxNewId();
+const long RipplePanel::ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style = wxNewId();
 const long RipplePanel::ID_CHECKBOX_Ripple3D = wxNewId();
 const long RipplePanel::ID_BITMAPBUTTON_CHECKBOX_Ripple3D = wxNewId();
 //*)
@@ -74,6 +108,8 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	//(*Initialize(RipplePanel)
 	BulkEditTextCtrl* TextCtrl33;
 	BulkEditTextCtrlF1* TextCtrl34;
+	wxFlexGridSizer* FlexGridSizer10;
+	wxFlexGridSizer* FlexGridSizer11;
 	wxFlexGridSizer* FlexGridSizer1;
 	wxFlexGridSizer* FlexGridSizer2;
 	wxFlexGridSizer* FlexGridSizer3;
@@ -81,8 +117,14 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	wxFlexGridSizer* FlexGridSizer57;
 	wxFlexGridSizer* FlexGridSizer5;
 	wxFlexGridSizer* FlexGridSizer60;
+	wxFlexGridSizer* FlexGridSizer6;
+	wxFlexGridSizer* FlexGridSizer7;
+	wxFlexGridSizer* FlexGridSizer8;
+	wxFlexGridSizer* FlexGridSizer9;
+	wxStaticText* StaticText_Outline;
+	wxStaticText* StaticText_SVG;
 
-	Create(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL, _T("wxID_ANY"));
+	Create(parent, wxID_ANY, wxDefaultPosition, wxSize(536,607), wxTAB_TRAVERSAL, _T("wxID_ANY"));
 	FlexGridSizer57 = new wxFlexGridSizer(0, 4, 0, 0);
 	FlexGridSizer57->AddGrowableCol(1);
 	StaticText69 = new wxStaticText(this, ID_STATICTEXT_Ripple_Object_To_Draw, _("Object to Draw"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Object_To_Draw"));
@@ -99,22 +141,60 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	Choice_Ripple_Object_To_Draw->Append(_("Snow Flake"));
 	Choice_Ripple_Object_To_Draw->Append(_("Crucifix"));
 	Choice_Ripple_Object_To_Draw->Append(_("Present"));
+	Choice_Ripple_Object_To_Draw->Append(_("SVG"));
 	FlexGridSizer57->Add(Choice_Ripple_Object_To_Draw, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	BitmapButton_Ripple_Object_To_Draw = new xlLockButton(this, ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw"));
 	BitmapButton_Ripple_Object_To_Draw->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
-	FlexGridSizer57->Add(BitmapButton_Ripple_Object_To_Draw, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer57->Add(BitmapButton_Ripple_Object_To_Draw, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText_SVG = new wxStaticText(this, wxID_ANY, _("SVG"), wxDefaultPosition, wxDefaultSize, 0, _T("wxID_ANY"));
+	FlexGridSizer57->Add(StaticText_SVG, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FilePickerCtrl_SVG = new BulkEditFilePickerCtrl(this, ID_FILEPICKERCTRL_SVG, wxEmptyString, _("Choose a SIMPLE svg file"), _T("*.svg"), wxDefaultPosition, wxDefaultSize, wxFLP_FILE_MUST_EXIST|wxFLP_OPEN|wxFLP_USE_TEXTCTRL, wxDefaultValidator, _T("ID_FILEPICKERCTRL_SVG"));
+	FlexGridSizer57->Add(FilePickerCtrl_SVG, 1, wxALL|wxEXPAND, 5);
+	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	StaticText70 = new wxStaticText(this, ID_STATICTEXT_Ripple_Movement, _("Movement"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Movement"));
 	FlexGridSizer57->Add(StaticText70, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	Choice_Ripple_Movement = new BulkEditChoice(this, ID_CHOICE_Ripple_Movement, wxDefaultPosition, wxDefaultSize, 0, 0, 0, wxDefaultValidator, _T("ID_CHOICE_Ripple_Movement"));
 	Choice_Ripple_Movement->SetSelection( Choice_Ripple_Movement->Append(_("Explode")) );
 	Choice_Ripple_Movement->Append(_("Implode"));
+	Choice_Ripple_Movement->Append(_("None"));
 	FlexGridSizer57->Add(Choice_Ripple_Movement, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	BitmapButton_Ripple_Movement = new xlLockButton(this, ID_BITMAPBUTTON_CHOICE_Ripple_Movement, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_CHOICE_Ripple_Movement"));
 	BitmapButton_Ripple_Movement->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
 	FlexGridSizer57->Add(BitmapButton_Ripple_Movement, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
-	StaticText72 = new wxStaticText(this, ID_STATICTEXT_Ripple_Thickness, _("Thickness"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Thickness"));
+	StaticText7 = new wxStaticText(this, ID_STATICTEXT6, _("Scale"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT6"));
+	FlexGridSizer57->Add(StaticText7, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer8 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer8->AddGrowableCol(0);
+	Slider_Ripple_Scale = new BulkEditSlider(this, ID_SLIDER_Ripple_Scale, 100, 0, 500, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_Scale"));
+	FlexGridSizer8->Add(Slider_Ripple_Scale, 1, wxALL|wxEXPAND, 2);
+	BitmapButton_Ripple_ScaleVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Scale, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Scale"));
+	FlexGridSizer8->Add(BitmapButton_Ripple_ScaleVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
+	FlexGridSizer57->Add(FlexGridSizer8, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Scale = new BulkEditTextCtrl(this, IDD_TEXTCTRL_Ripple_Scale, _("100"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("IDD_TEXTCTRL_Ripple_Scale"));
+	TextCtrl_Ripple_Scale->SetMaxLength(3);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Scale, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Scale = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Scale, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Scale"));
+	BitmapButton_Ripple_Scale->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Scale, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText_Outline = new wxStaticText(this, wxID_ANY, _("Outline"), wxDefaultPosition, wxDefaultSize, 0, _T("wxID_ANY"));
+	FlexGridSizer57->Add(StaticText_Outline, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer11 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer11->AddGrowableCol(0);
+	Slider_Ripple_Outline = new BulkEditSliderF1(this, IDD_SLIDER_Ripple_Outline, 10, 0, 100, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("IDD_SLIDER_Ripple_Outline"));
+	FlexGridSizer11->Add(Slider_Ripple_Outline, 1, wxALL|wxEXPAND, 5);
+	BitmapButton_Ripple_OutlineVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Outline, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Outline"));
+	FlexGridSizer11->Add(BitmapButton_Ripple_OutlineVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
+	FlexGridSizer57->Add(FlexGridSizer11, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Outline = new BulkEditTextCtrlF1(this, ID_TEXTCTRL_Ripple_Outline, _("1.0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("ID_TEXTCTRL_Ripple_Outline"));
+	TextCtrl_Ripple_Outline->SetMaxLength(4);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Outline, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Outline = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Outline, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Outline"));
+	BitmapButton_Ripple_Outline->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Outline, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText72 = new wxStaticText(this, ID_STATICTEXT_Ripple_Thickness, _("Ripples"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Thickness"));
 	FlexGridSizer57->Add(StaticText72, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer1 = new wxFlexGridSizer(0, 2, 0, 0);
 	FlexGridSizer1->AddGrowableCol(0);
@@ -122,13 +202,28 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	FlexGridSizer1->Add(Slider_Ripple_Thickness, 1, wxALL|wxEXPAND, 2);
 	BitmapButton_Ripple_ThicknessVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Thickness, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Thickness"));
 	FlexGridSizer1->Add(BitmapButton_Ripple_ThicknessVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
-	FlexGridSizer57->Add(FlexGridSizer1, 1, wxALL|wxEXPAND, 2);
+	FlexGridSizer57->Add(FlexGridSizer1, 1, wxALL|wxEXPAND, 0);
 	TextCtrl33 = new BulkEditTextCtrl(this, IDD_TEXTCTRL_Ripple_Thickness, _("3"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("IDD_TEXTCTRL_Ripple_Thickness"));
 	TextCtrl33->SetMaxLength(3);
 	FlexGridSizer57->Add(TextCtrl33, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
 	BitmapButton_RippleThickness = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Thickness, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Thickness"));
 	BitmapButton_RippleThickness->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
 	FlexGridSizer57->Add(BitmapButton_RippleThickness, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText4 = new wxStaticText(this, ID_STATICTEXT4, _("Spacing"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT4"));
+	FlexGridSizer57->Add(StaticText4, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer6 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer6->AddGrowableCol(0);
+	Slider_Ripple_Spacing = new BulkEditSliderF1(this, IDD_SLIDER_Ripple_Spacing, 10, 1, 400, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("IDD_SLIDER_Ripple_Spacing"));
+	FlexGridSizer6->Add(Slider_Ripple_Spacing, 1, wxALL|wxEXPAND, 2);
+	BitmapButton_Ripple_SpacingVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Spacing, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Spacing"));
+	FlexGridSizer6->Add(BitmapButton_Ripple_SpacingVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
+	FlexGridSizer57->Add(FlexGridSizer6, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Spacing = new BulkEditTextCtrlF1(this, ID_TEXTCTRL_Ripple_Spacing, _("1.0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("ID_TEXTCTRL_Ripple_Spacing"));
+	TextCtrl_Ripple_Spacing->SetMaxLength(4);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Spacing, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Spacing = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Spacing, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Spacing"));
+	BitmapButton_Ripple_Spacing->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Spacing, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
 	StaticText176 = new wxStaticText(this, ID_STATICTEXT_Ripple_Cycles, _("Cycle Count"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Cycles"));
 	FlexGridSizer57->Add(StaticText176, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer2 = new wxFlexGridSizer(0, 2, 0, 0);
@@ -137,7 +232,7 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	FlexGridSizer2->Add(Slider_Ripple_Cycles, 1, wxALL|wxEXPAND, 2);
 	BitmapButton_Ripple_CyclesVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Cycles, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Cycles"));
 	FlexGridSizer2->Add(BitmapButton_Ripple_CyclesVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
-	FlexGridSizer57->Add(FlexGridSizer2, 1, wxALL|wxEXPAND, 2);
+	FlexGridSizer57->Add(FlexGridSizer2, 1, wxALL|wxEXPAND, 0);
 	TextCtrl34 = new BulkEditTextCtrlF1(this, ID_TEXTCTRL_Ripple_Cycles, _("1.0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("ID_TEXTCTRL_Ripple_Cycles"));
 	TextCtrl34->SetMaxLength(4);
 	FlexGridSizer57->Add(TextCtrl34, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
@@ -151,12 +246,12 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	FlexGridSizer57->Add(TextCtrl_Ripple_Points, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	BitmapButton_Ripple_Points = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_RIPPLE_POINTS, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_RIPPLE_POINTS"));
 	BitmapButton_Ripple_Points->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
-	FlexGridSizer57->Add(BitmapButton_Ripple_Points, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer57->Add(BitmapButton_Ripple_Points, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
 	StaticText_Ripple_Rotation = new wxStaticText(this, ID_STATICTEXT_Ripple_Rotation, _("Rotation"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Rotation"));
 	FlexGridSizer57->Add(StaticText_Ripple_Rotation, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer3 = new wxFlexGridSizer(0, 2, 0, 0);
 	FlexGridSizer3->AddGrowableCol(0);
-	Slider_Ripple_Rotation = new BulkEditSlider(this, ID_SLIDER_Ripple_Rotation, 0, 0, 360, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_Rotation"));
+	Slider_Ripple_Rotation = new BulkEditSlider(this, ID_SLIDER_Ripple_Rotation, 0, -360, 360, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_Rotation"));
 	FlexGridSizer3->Add(Slider_Ripple_Rotation, 1, wxALL|wxEXPAND, 2);
 	BitmapButton_Ripple_RotationVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Rotation, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Rotation"));
 	FlexGridSizer3->Add(BitmapButton_Ripple_RotationVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
@@ -167,9 +262,25 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	BitmapButton_Ripple_Rotation = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Rotation, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Rotation"));
 	BitmapButton_Ripple_Rotation->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
 	FlexGridSizer57->Add(BitmapButton_Ripple_Rotation, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText6 = new wxStaticText(this, ID_STATICTEXT5, _("Twist"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT5"));
+	FlexGridSizer57->Add(StaticText6, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer7 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer7->AddGrowableCol(0);
+	Slider_Ripple_Twist = new BulkEditSliderF1(this, IDD_SLIDER_Ripple_Twist, 0, -450, 450, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("IDD_SLIDER_Ripple_Twist"));
+	FlexGridSizer7->Add(Slider_Ripple_Twist, 1, wxALL|wxEXPAND, 2);
+	BitmapButton_Ripple_TwistVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Twist, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Twist"));
+	FlexGridSizer7->Add(BitmapButton_Ripple_TwistVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
+	FlexGridSizer57->Add(FlexGridSizer7, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Twist = new BulkEditTextCtrlF1(this, ID_TEXTCTRL_Ripple_Twist, _("0.0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("ID_TEXTCTRL_Ripple_Twist"));
+	TextCtrl_Ripple_Twist->SetMaxLength(4);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Twist, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Twist = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Twist, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Twist"));
+	BitmapButton_Ripple_Twist->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Twist, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
 	StaticText2 = new wxStaticText(this, ID_STATICTEXT2, _("X Center"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT2"));
 	FlexGridSizer57->Add(StaticText2, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer4 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer4->AddGrowableCol(0);
 	Slider_Ripple_XC = new BulkEditSlider(this, ID_SLIDER_Ripple_XC, 0, -100, 100, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_XC"));
 	FlexGridSizer4->Add(Slider_Ripple_XC, 1, wxALL|wxEXPAND, 2);
 	BitmapButton_Ripple_XCVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_XC, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_XC"));
@@ -182,6 +293,7 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	StaticText3 = new wxStaticText(this, ID_STATICTEXT3, _("Y Center"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT3"));
 	FlexGridSizer57->Add(StaticText3, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer5 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer5->AddGrowableCol(0);
 	Slider_Ripple_YC = new BulkEditSlider(this, ID_SLIDER_Ripple_YC, 0, -100, 100, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_YC"));
 	FlexGridSizer5->Add(Slider_Ripple_YC, 1, wxALL|wxEXPAND, 2);
 	BitmapButton_Ripple_YCVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_YC, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_YC"));
@@ -191,6 +303,63 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	TextCtrl_Ripple_YC->SetMaxLength(3);
 	FlexGridSizer57->Add(TextCtrl_Ripple_YC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	StaticText8 = new wxStaticText(this, ID_STATICTEXT7, _("Velocity"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT7"));
+	FlexGridSizer57->Add(StaticText8, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer9 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer9->AddGrowableCol(0);
+	Slider_Ripple_Velocity = new BulkEditSliderF1(this, IDD_SLIDER_Ripple_Velocity, 0, 0, 300, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("IDD_SLIDER_Ripple_Velocity"));
+	FlexGridSizer9->Add(Slider_Ripple_Velocity, 1, wxALL|wxEXPAND, 2);
+	BitmapButton_Ripple_VelocityVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Velocity, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Velocity"));
+	FlexGridSizer9->Add(BitmapButton_Ripple_VelocityVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer57->Add(FlexGridSizer9, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Velocity = new BulkEditTextCtrlF1(this, ID_TEXTCTRL_Ripple_Velocity, _("0.0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("ID_TEXTCTRL_Ripple_Velocity"));
+	TextCtrl_Ripple_Velocity->SetMaxLength(4);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Velocity, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Velocity = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Velocity, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Velocity"));
+	BitmapButton_Ripple_Velocity->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Velocity, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText9 = new wxStaticText(this, ID_STATICTEXT8, _("Direction"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT8"));
+	FlexGridSizer57->Add(StaticText9, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer10 = new wxFlexGridSizer(0, 2, 0, 0);
+	FlexGridSizer10->AddGrowableCol(0);
+	Slider_Ripple_Direction = new BulkEditSlider(this, ID_SLIDER_Ripple_Direction, 0, -360, 360, wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_SLIDER_Ripple_Direction"));
+	FlexGridSizer10->Add(Slider_Ripple_Direction, 1, wxALL|wxEXPAND, 2);
+	BitmapButton_Ripple_DirectionVC = new BulkEditValueCurveButton(this, ID_VALUECURVE_Ripple_Direction, GetValueCurveNotSelectedBitmap(), wxDefaultPosition, wxDefaultSize, wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_VALUECURVE_Ripple_Direction"));
+	FlexGridSizer10->Add(BitmapButton_Ripple_DirectionVC, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 2);
+	FlexGridSizer57->Add(FlexGridSizer10, 1, wxALL|wxEXPAND, 0);
+	TextCtrl_Ripple_Direction = new BulkEditTextCtrl(this, IDD_TEXTCTRL_Ripple_Direction, _("0"), wxDefaultPosition, wxDLG_UNIT(this,wxSize(20,-1)), 0, wxDefaultValidator, _T("IDD_TEXTCTRL_Ripple_Direction"));
+	TextCtrl_Ripple_Direction->SetMaxLength(3);
+	FlexGridSizer57->Add(TextCtrl_Ripple_Direction, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Direction = new xlLockButton(this, ID_BITMAPBUTTON_SLIDER_Ripple_Direction, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_SLIDER_Ripple_Direction"));
+	BitmapButton_Ripple_Direction->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Direction, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
+	StaticText5 = new wxStaticText(this, ID_STATICTEXT_Ripple_Draw_Style, _("Draw Style"), wxDefaultPosition, wxDefaultSize, 0, _T("ID_STATICTEXT_Ripple_Draw_Style"));
+	FlexGridSizer57->Add(StaticText5, 1, wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL, 5);
+	Choice_Ripple_Draw_Style = new BulkEditChoice(this, ID_CHOICE_Ripple_Draw_Style, wxDefaultPosition, wxDefaultSize, 0, 0, 0, wxDefaultValidator, _T("ID_CHOICE_Ripple_Draw_Style"));
+	Choice_Ripple_Draw_Style->Append(_("Old"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Inward"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Outward"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Both"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Inward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Outward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Lines Both Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Inward"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Outward"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Both"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Inward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Outward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Solid Both Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Inward"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Outward"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Both"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Inward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Outward Ripple"));
+	Choice_Ripple_Draw_Style->Append(_("Highlight Both Ripple"));
+	FlexGridSizer57->Add(Choice_Ripple_Draw_Style, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
+	BitmapButton_Ripple_Draw_Style = new xlLockButton(this, ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style, wxNullBitmap, wxDefaultPosition, wxSize(14,14), wxBU_AUTODRAW|wxBORDER_NONE, wxDefaultValidator, _T("ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style"));
+	BitmapButton_Ripple_Draw_Style->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
+	FlexGridSizer57->Add(BitmapButton_Ripple_Draw_Style, 1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 1);
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer60 = new wxFlexGridSizer(0, 4, 0, 0);
 	CheckBox_Ripple3D = new BulkEditCheckBox(this, ID_CHECKBOX_Ripple3D, _("3D"), wxDefaultPosition, wxDefaultSize, 0, wxDefaultValidator, _T("ID_CHECKBOX_Ripple3D"));
@@ -203,18 +372,37 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	FlexGridSizer57->Add(-1,-1,1, wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL, 5);
 	SetSizer(FlexGridSizer57);
+	SetSizer(FlexGridSizer57);
+	Layout();
 
 	Connect(ID_CHOICE_Ripple_Object_To_Draw,wxEVT_COMMAND_CHOICE_SELECTED,(wxObjectEventFunction)&RipplePanel::OnChoice_Ripple_Object_To_DrawSelect);
-	Connect(ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
 	Connect(ID_BITMAPBUTTON_CHOICE_Ripple_Movement,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
-	Connect(ID_VALUECURVE_Ripple_Thickness,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
-	Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Thickness,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
 	Connect(ID_VALUECURVE_Ripple_Cycles,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
 	Connect(ID_BITMAPBUTTON_SLIDER_RIPPLE_POINTS,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
-	Connect(ID_BITMAPBUTTON_CHECKBOX_Ripple3D,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
 	//*)
     SetName("ID_PANEL_RIPPLE");
 
+	Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Thickness, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Thickness, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_CHECKBOX_Ripple3D, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+	Connect(ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_CHOICE_Ripple_Draw_Style, wxEVT_COMMAND_CHOICE_SELECTED, (wxObjectEventFunction)&RipplePanel::OnChoice_Ripple_Draw_StyleSelect);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Rotation, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Scale, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Scale, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Spacing, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Spacing, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Velocity, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Velocity, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Direction, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Direction, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Twist, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Twist, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+    Connect(ID_BITMAPBUTTON_SLIDER_Ripple_Outline, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnLockButtonClick);
+    Connect(ID_VALUECURVE_Ripple_Outline, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
+
 	Connect(ID_VALUECURVE_Ripple_XC, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
 	Connect(ID_VALUECURVE_Ripple_YC, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
     Connect(ID_VALUECURVE_Ripple_Rotation, wxEVT_COMMAND_BUTTON_CLICKED, (wxObjectEventFunction)&RipplePanel::OnVCButtonClick);
@@ -222,12 +410,22 @@ RipplePanel::RipplePanel(wxWindow* parent) : xlEffectPanel(parent)
     Connect(wxID_ANY, EVT_VC_CHANGED, (wxObjectEventFunction)&RipplePanel::OnVCChanged, 0, this);
     Connect(wxID_ANY, EVT_VALIDATEWINDOW, (wxObjectEventFunction)&RipplePanel::OnValidateWindow, 0, this);
 
-	BitmapButton_Ripple_XCVC->GetValue()->SetLimits(RIPPLE_XC_MIN, RIPPLE_XC_MAX);
-	BitmapButton_Ripple_YCVC->GetValue()->SetLimits(RIPPLE_YC_MIN, RIPPLE_YC_MAX);
-    BitmapButton_Ripple_RotationVC->GetValue()->SetLimits(RIPPLE_ROTATION_MIN, RIPPLE_ROTATION_MAX);
-	BitmapButton_Ripple_CyclesVC->GetValue()->SetLimits(RIPPLE_CYCLES_MIN, RIPPLE_CYCLES_MAX);
-    BitmapButton_Ripple_CyclesVC->GetValue()->SetDivisor(10);
-    BitmapButton_Ripple_ThicknessVC->GetValue()->SetLimits(RIPPLE_THICKNESS_MIN, RIPPLE_THICKNESS_MAX);
+	BitmapButton_Ripple_XCVC->SetLimits(RIPPLE_XC_MIN, RIPPLE_XC_MAX);
+	BitmapButton_Ripple_YCVC->SetLimits(RIPPLE_YC_MIN, RIPPLE_YC_MAX);
+    BitmapButton_Ripple_RotationVC->SetLimits(RIPPLE_ROTATION_MIN, RIPPLE_ROTATION_MAX);
+	BitmapButton_Ripple_CyclesVC->SetLimits(RIPPLE_CYCLES_MIN, RIPPLE_CYCLES_MAX);
+    BitmapButton_Ripple_CyclesVC->GetValue()->SetDivisor(RIPPLE_CYCLES_DIVISOR);
+    BitmapButton_Ripple_ThicknessVC->SetLimits(RIPPLE_THICKNESS_MIN, RIPPLE_THICKNESS_MAX);
+    BitmapButton_Ripple_ScaleVC->SetLimits(RIPPLE_SCALE_MIN, RIPPLE_SCALE_MAX);
+    BitmapButton_Ripple_SpacingVC->SetLimits(RIPPLE_SPACING_MIN, RIPPLE_SPACING_MAX);
+    BitmapButton_Ripple_SpacingVC->GetValue()->SetDivisor(RIPPLE_SPACING_DIVISOR);
+    BitmapButton_Ripple_OutlineVC->SetLimits(RIPPLE_OUTLINE_MIN, RIPPLE_OUTLINE_MAX);
+    BitmapButton_Ripple_OutlineVC->GetValue()->SetDivisor(RIPPLE_OUTLINE_DIVISOR);
+    BitmapButton_Ripple_TwistVC->SetLimits(RIPPLE_TWIST_MIN, RIPPLE_TWIST_MAX);
+    BitmapButton_Ripple_TwistVC->GetValue()->SetDivisor(RIPPLE_TWIST_DIVISOR);
+    BitmapButton_Ripple_VelocityVC->SetLimits(RIPPLE_VELOCITY_MIN, RIPPLE_VELOCITY_MAX);
+    BitmapButton_Ripple_VelocityVC->GetValue()->SetDivisor(RIPPLE_VELOCITY_DIVISOR);
+    BitmapButton_Ripple_DirectionVC->SetLimits(RIPPLE_DIRECTION_MIN, RIPPLE_DIRECTION_MAX);
 
     ValidateWindow();
 }
@@ -267,4 +465,60 @@ void RipplePanel::ValidateWindow()
 		TextCtrl_Ripple_Rotation->Disable();
         BitmapButton_Ripple_RotationVC->Disable();
     }
+
+    bool newFeatures = false;
+    if (Choice_Ripple_Draw_Style->GetStringSelection() != "Old") {
+        BitmapButton_Ripple_Rotation->Enable();
+        Slider_Ripple_Rotation->Enable();
+        TextCtrl_Ripple_Rotation->Enable();
+        BitmapButton_Ripple_RotationVC->Enable();
+
+        newFeatures = true;
+    }
+
+	if (!newFeatures && Choice_Ripple_Object_To_Draw->GetStringSelection() == "SVG") {
+        Choice_Ripple_Object_To_Draw->SetStringSelection("Circle");
+    }
+
+	if (newFeatures && Choice_Ripple_Object_To_Draw->GetStringSelection() == "SVG") {
+        FilePickerCtrl_SVG->Enable();
+    } else {
+        FilePickerCtrl_SVG->Enable(false);
+        FilePickerCtrl_SVG->SetFileName(wxFileName(""));
+    }
+
+	BitmapButton_Ripple_Scale->Enable(newFeatures);
+    Slider_Ripple_Scale->Enable(newFeatures);
+    TextCtrl_Ripple_Scale->Enable(newFeatures);
+    BitmapButton_Ripple_ScaleVC->Enable(newFeatures);
+
+    BitmapButton_Ripple_Spacing->Enable(newFeatures);
+    Slider_Ripple_Spacing->Enable(newFeatures);
+    TextCtrl_Ripple_Spacing->Enable(newFeatures);
+    BitmapButton_Ripple_SpacingVC->Enable(newFeatures);
+
+    BitmapButton_Ripple_Twist->Enable(newFeatures);
+    Slider_Ripple_Twist->Enable(newFeatures);
+    TextCtrl_Ripple_Twist->Enable(newFeatures);
+    BitmapButton_Ripple_TwistVC->Enable(newFeatures);
+
+    BitmapButton_Ripple_Direction->Enable(newFeatures);
+    Slider_Ripple_Direction->Enable(newFeatures);
+    TextCtrl_Ripple_Direction->Enable(newFeatures);
+    BitmapButton_Ripple_DirectionVC->Enable(newFeatures);
+
+    BitmapButton_Ripple_Velocity->Enable(newFeatures);
+    Slider_Ripple_Velocity->Enable(newFeatures);
+    TextCtrl_Ripple_Velocity->Enable(newFeatures);
+    BitmapButton_Ripple_VelocityVC->Enable(newFeatures);
+
+	BitmapButton_Ripple_Outline->Enable(newFeatures);
+    Slider_Ripple_Outline->Enable(newFeatures);
+    TextCtrl_Ripple_Outline->Enable(newFeatures);
+    BitmapButton_Ripple_OutlineVC->Enable(newFeatures);
+}
+
+void RipplePanel::OnChoice_Ripple_Draw_StyleSelect(wxCommandEvent& event)
+{
+    ValidateWindow();
 }
diff --git a/xLights/effects/RipplePanel.h b/xLights/effects/RipplePanel.h
index 5db7cad83..388e47a1f 100644
--- a/xLights/effects/RipplePanel.h
+++ b/xLights/effects/RipplePanel.h
@@ -15,6 +15,7 @@
 class wxBitmapButton;
 class wxCheckBox;
 class wxChoice;
+class wxFilePickerCtrl;
 class wxFlexGridSizer;
 class wxSlider;
 class wxStaticText;
@@ -34,37 +35,70 @@ class RipplePanel: public xlEffectPanel
 
 		//(*Declarations(RipplePanel)
 		BulkEditCheckBox* CheckBox_Ripple3D;
+		BulkEditChoice* Choice_Ripple_Draw_Style;
 		BulkEditChoice* Choice_Ripple_Movement;
 		BulkEditChoice* Choice_Ripple_Object_To_Draw;
+		BulkEditFilePickerCtrl* FilePickerCtrl_SVG;
+		BulkEditSlider* Slider_Ripple_Direction;
 		BulkEditSlider* Slider_Ripple_Points;
 		BulkEditSlider* Slider_Ripple_Rotation;
+		BulkEditSlider* Slider_Ripple_Scale;
 		BulkEditSlider* Slider_Ripple_Thickness;
 		BulkEditSlider* Slider_Ripple_XC;
 		BulkEditSlider* Slider_Ripple_YC;
 		BulkEditSliderF1* Slider_Ripple_Cycles;
+		BulkEditSliderF1* Slider_Ripple_Outline;
+		BulkEditSliderF1* Slider_Ripple_Spacing;
+		BulkEditSliderF1* Slider_Ripple_Twist;
+		BulkEditSliderF1* Slider_Ripple_Velocity;
+		BulkEditTextCtrl* TextCtrl_Ripple_Direction;
 		BulkEditTextCtrl* TextCtrl_Ripple_Points;
 		BulkEditTextCtrl* TextCtrl_Ripple_Rotation;
+		BulkEditTextCtrl* TextCtrl_Ripple_Scale;
 		BulkEditTextCtrl* TextCtrl_Ripple_XC;
 		BulkEditTextCtrl* TextCtrl_Ripple_YC;
+		BulkEditTextCtrlF1* TextCtrl_Ripple_Outline;
+		BulkEditTextCtrlF1* TextCtrl_Ripple_Spacing;
+		BulkEditTextCtrlF1* TextCtrl_Ripple_Twist;
+		BulkEditTextCtrlF1* TextCtrl_Ripple_Velocity;
 		BulkEditValueCurveButton* BitmapButton_Ripple_CyclesVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_DirectionVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_OutlineVC;
 		BulkEditValueCurveButton* BitmapButton_Ripple_RotationVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_ScaleVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_SpacingVC;
 		BulkEditValueCurveButton* BitmapButton_Ripple_ThicknessVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_TwistVC;
+		BulkEditValueCurveButton* BitmapButton_Ripple_VelocityVC;
 		BulkEditValueCurveButton* BitmapButton_Ripple_XCVC;
 		BulkEditValueCurveButton* BitmapButton_Ripple_YCVC;
 		wxStaticText* StaticText176;
 		wxStaticText* StaticText1;
 		wxStaticText* StaticText2;
 		wxStaticText* StaticText3;
+		wxStaticText* StaticText4;
+		wxStaticText* StaticText5;
 		wxStaticText* StaticText69;
+		wxStaticText* StaticText6;
 		wxStaticText* StaticText70;
 		wxStaticText* StaticText72;
+		wxStaticText* StaticText7;
+		wxStaticText* StaticText8;
+		wxStaticText* StaticText9;
 		wxStaticText* StaticText_Ripple_Rotation;
 		xlLockButton* BitmapButton_Ripple3D;
 		xlLockButton* BitmapButton_RippleThickness;
+		xlLockButton* BitmapButton_Ripple_Direction;
+		xlLockButton* BitmapButton_Ripple_Draw_Style;
 		xlLockButton* BitmapButton_Ripple_Movement;
 		xlLockButton* BitmapButton_Ripple_Object_To_Draw;
+		xlLockButton* BitmapButton_Ripple_Outline;
 		xlLockButton* BitmapButton_Ripple_Points;
 		xlLockButton* BitmapButton_Ripple_Rotation;
+		xlLockButton* BitmapButton_Ripple_Scale;
+		xlLockButton* BitmapButton_Ripple_Spacing;
+		xlLockButton* BitmapButton_Ripple_Twist;
+		xlLockButton* BitmapButton_Ripple_Velocity;
 		//*)
 
 	protected:
@@ -73,14 +107,29 @@ class RipplePanel: public xlEffectPanel
 		static const long ID_STATICTEXT_Ripple_Object_To_Draw;
 		static const long ID_CHOICE_Ripple_Object_To_Draw;
 		static const long ID_BITMAPBUTTON_CHOICE_Ripple_Object_To_Draw;
+		static const long ID_FILEPICKERCTRL_SVG;
 		static const long ID_STATICTEXT_Ripple_Movement;
 		static const long ID_CHOICE_Ripple_Movement;
 		static const long ID_BITMAPBUTTON_CHOICE_Ripple_Movement;
+		static const long ID_STATICTEXT6;
+		static const long ID_SLIDER_Ripple_Scale;
+		static const long ID_VALUECURVE_Ripple_Scale;
+		static const long IDD_TEXTCTRL_Ripple_Scale;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Scale;
+		static const long IDD_SLIDER_Ripple_Outline;
+		static const long ID_VALUECURVE_Ripple_Outline;
+		static const long ID_TEXTCTRL_Ripple_Outline;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Outline;
 		static const long ID_STATICTEXT_Ripple_Thickness;
 		static const long ID_SLIDER_Ripple_Thickness;
 		static const long ID_VALUECURVE_Ripple_Thickness;
 		static const long IDD_TEXTCTRL_Ripple_Thickness;
 		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Thickness;
+		static const long ID_STATICTEXT4;
+		static const long IDD_SLIDER_Ripple_Spacing;
+		static const long ID_VALUECURVE_Ripple_Spacing;
+		static const long ID_TEXTCTRL_Ripple_Spacing;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Spacing;
 		static const long ID_STATICTEXT_Ripple_Cycles;
 		static const long IDD_SLIDER_Ripple_Cycles;
 		static const long ID_VALUECURVE_Ripple_Cycles;
@@ -94,6 +143,11 @@ class RipplePanel: public xlEffectPanel
 		static const long ID_VALUECURVE_Ripple_Rotation;
 		static const long IDD_TEXTCTRL_Ripple_Rotation;
 		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Rotation;
+		static const long ID_STATICTEXT5;
+		static const long IDD_SLIDER_Ripple_Twist;
+		static const long ID_VALUECURVE_Ripple_Twist;
+		static const long ID_TEXTCTRL_Ripple_Twist;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Twist;
 		static const long ID_STATICTEXT2;
 		static const long ID_SLIDER_Ripple_XC;
 		static const long ID_VALUECURVE_Ripple_XC;
@@ -102,6 +156,19 @@ class RipplePanel: public xlEffectPanel
 		static const long ID_SLIDER_Ripple_YC;
 		static const long ID_VALUECURVE_Ripple_YC;
 		static const long IDD_TEXTCTRL_Ripple_YC;
+		static const long ID_STATICTEXT7;
+		static const long IDD_SLIDER_Ripple_Velocity;
+		static const long ID_VALUECURVE_Ripple_Velocity;
+		static const long ID_TEXTCTRL_Ripple_Velocity;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Velocity;
+		static const long ID_STATICTEXT8;
+		static const long ID_SLIDER_Ripple_Direction;
+		static const long ID_VALUECURVE_Ripple_Direction;
+		static const long IDD_TEXTCTRL_Ripple_Direction;
+		static const long ID_BITMAPBUTTON_SLIDER_Ripple_Direction;
+		static const long ID_STATICTEXT_Ripple_Draw_Style;
+		static const long ID_CHOICE_Ripple_Draw_Style;
+		static const long ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style;
 		static const long ID_CHECKBOX_Ripple3D;
 		static const long ID_BITMAPBUTTON_CHECKBOX_Ripple3D;
 		//*)
@@ -110,6 +177,7 @@ class RipplePanel: public xlEffectPanel
 
 		//(*Handlers(RipplePanel)
 		void OnChoice_Ripple_Object_To_DrawSelect(wxCommandEvent& event);
+		void OnChoice_Ripple_Draw_StyleSelect(wxCommandEvent& event);
 		//*)
 
 		DECLARE_EVENT_TABLE()
diff --git a/xLights/effects/ShapePanel.cpp b/xLights/effects/ShapePanel.cpp
index 3a11a95ba..fb7f4e640 100644
--- a/xLights/effects/ShapePanel.cpp
+++ b/xLights/effects/ShapePanel.cpp
@@ -588,7 +588,8 @@ void ShapePanel::ValidateWindow()
     }
 
     if (Choice_Shape_ObjectToDraw->GetStringSelection() == "Snowflake" ||
-        Choice_Shape_ObjectToDraw->GetStringSelection() == "Emoji") {
+        Choice_Shape_ObjectToDraw->GetStringSelection() == "Emoji")
+    {
         Slider_Shape_Thickness->Disable();
         TextCtrl_Shape_Thickness->Disable();
     } else {
@@ -606,7 +607,8 @@ void ShapePanel::ValidateWindow()
 		Choice_Shape_ObjectToDraw->GetStringSelection() == "Candy Cane" ||
         Choice_Shape_ObjectToDraw->GetStringSelection() == "SVG" ||
         Choice_Shape_ObjectToDraw->GetStringSelection() == "Random" ||
-        Choice_Shape_ObjectToDraw->GetStringSelection() == "Circle" ) {
+        Choice_Shape_ObjectToDraw->GetStringSelection() == "Circle" )
+    {
 		Slider_Shape_Rotation->Disable();
 		TextCtrl_Shape_Rotation->Disable();
 		BitmapButton_Shape_RotationVC->Disable();
diff --git a/xLights/wxsmith/RipplePanel.wxs b/xLights/wxsmith/RipplePanel.wxs
index 98df0ea0f..0473d7f20 100755
--- a/xLights/wxsmith/RipplePanel.wxs
+++ b/xLights/wxsmith/RipplePanel.wxs
@@ -1,6 +1,7 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <wxsmith>
 	<object class="wxPanel" name="RipplePanel">
+		<size>536,607</size>
 		<id_arg>0</id_arg>
 		<object class="wxFlexGridSizer" variable="FlexGridSizer57" member="no">
 			<cols>4</cols>
@@ -27,6 +28,7 @@
 						<item>Snow Flake</item>
 						<item>Crucifix</item>
 						<item>Present</item>
+						<item>SVG</item>
 					</content>
 					<selection>0</selection>
 					<handler function="OnChoice_Ripple_Object_To_DrawSelect" entry="EVT_CHOICE" />
@@ -45,9 +47,35 @@
 					<size>14,14</size>
 					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
 					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
-					<handler function="OnLockButtonClick" entry="EVT_BUTTON" />
 				</object>
 				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="wxID_ANY" variable="StaticText_SVG" member="no">
+					<label>SVG</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFilePickerCtrl" name="ID_FILEPICKERCTRL_SVG" subclass="BulkEditFilePickerCtrl" variable="FilePickerCtrl_SVG" member="yes">
+					<message>Choose a SIMPLE svg file</message>
+					<wildcard>*.svg</wildcard>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="spacer">
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="spacer">
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
 				<border>5</border>
 				<option>1</option>
 			</object>
@@ -64,6 +92,7 @@
 					<content>
 						<item>Explode</item>
 						<item>Implode</item>
+						<item>None</item>
 					</content>
 					<selection>0</selection>
 				</object>
@@ -87,9 +116,116 @@
 				<border>1</border>
 				<option>1</option>
 			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT6" variable="StaticText7" member="yes">
+					<label>Scale</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer8" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="ID_SLIDER_Ripple_Scale" subclass="BulkEditSlider" variable="Slider_Ripple_Scale" member="yes">
+							<value>100</value>
+							<max>500</max>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Scale" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_ScaleVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="IDD_TEXTCTRL_Ripple_Scale" subclass="BulkEditTextCtrl" variable="TextCtrl_Ripple_Scale" member="yes">
+					<value>100</value>
+					<maxlength>3</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Scale" subclass="xlLockButton" variable="BitmapButton_Ripple_Scale" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="wxID_ANY" variable="StaticText_Outline" member="no">
+					<label>Outline</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer11" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="IDD_SLIDER_Ripple_Outline" subclass="BulkEditSliderF1" variable="Slider_Ripple_Outline" member="yes">
+							<value>10</value>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>5</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Outline" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_OutlineVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="ID_TEXTCTRL_Ripple_Outline" subclass="BulkEditTextCtrlF1" variable="TextCtrl_Ripple_Outline" member="yes">
+					<value>1.0</value>
+					<maxlength>4</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Outline" subclass="xlLockButton" variable="BitmapButton_Ripple_Outline" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
 			<object class="sizeritem">
 				<object class="wxStaticText" name="ID_STATICTEXT_Ripple_Thickness" variable="StaticText72" member="yes">
-					<label>Thickness</label>
+					<label>Ripples</label>
 				</object>
 				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
 				<border>5</border>
@@ -112,7 +248,6 @@
 						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Thickness" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_ThicknessVC" member="yes">
 							<bitmap code="GetValueCurveNotSelectedBitmap()" />
 							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
-							<handler function="OnVCButtonClick" entry="EVT_BUTTON" />
 						</object>
 						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
 						<border>2</border>
@@ -120,7 +255,6 @@
 					</object>
 				</object>
 				<flag>wxALL|wxEXPAND</flag>
-				<border>2</border>
 				<option>1</option>
 			</object>
 			<object class="sizeritem">
@@ -138,7 +272,61 @@
 					<size>14,14</size>
 					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
 					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
-					<handler function="OnLockButtonClick" entry="EVT_BUTTON" />
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT4" variable="StaticText4" member="yes">
+					<label>Spacing</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer6" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="IDD_SLIDER_Ripple_Spacing" subclass="BulkEditSliderF1" variable="Slider_Ripple_Spacing" member="yes">
+							<value>10</value>
+							<min>1</min>
+							<max>400</max>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Spacing" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_SpacingVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="ID_TEXTCTRL_Ripple_Spacing" subclass="BulkEditTextCtrlF1" variable="TextCtrl_Ripple_Spacing" member="yes">
+					<value>1.0</value>
+					<maxlength>4</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Spacing" subclass="xlLockButton" variable="BitmapButton_Ripple_Spacing" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
 				</object>
 				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
 				<border>1</border>
@@ -177,7 +365,6 @@
 					</object>
 				</object>
 				<flag>wxALL|wxEXPAND</flag>
-				<border>2</border>
 				<option>1</option>
 			</object>
 			<object class="sizeritem">
@@ -231,7 +418,7 @@
 					<handler function="OnLockButtonClick" entry="EVT_BUTTON" />
 				</object>
 				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
-				<border>5</border>
+				<border>1</border>
 				<option>1</option>
 			</object>
 			<object class="sizeritem">
@@ -248,6 +435,7 @@
 					<growablecols>0</growablecols>
 					<object class="sizeritem">
 						<object class="wxSlider" name="ID_SLIDER_Ripple_Rotation" subclass="BulkEditSlider" variable="Slider_Ripple_Rotation" member="yes">
+							<min>-360</min>
 							<max>360</max>
 						</object>
 						<flag>wxALL|wxEXPAND</flag>
@@ -287,6 +475,60 @@
 				<border>1</border>
 				<option>1</option>
 			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT5" variable="StaticText6" member="yes">
+					<label>Twist</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer7" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="IDD_SLIDER_Ripple_Twist" subclass="BulkEditSliderF1" variable="Slider_Ripple_Twist" member="yes">
+							<min>-450</min>
+							<max>450</max>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Twist" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_TwistVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="ID_TEXTCTRL_Ripple_Twist" subclass="BulkEditTextCtrlF1" variable="TextCtrl_Ripple_Twist" member="yes">
+					<value>0.0</value>
+					<maxlength>4</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Twist" subclass="xlLockButton" variable="BitmapButton_Ripple_Twist" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
 			<object class="sizeritem">
 				<object class="wxStaticText" name="ID_STATICTEXT2" variable="StaticText2" member="yes">
 					<label>X Center</label>
@@ -298,6 +540,7 @@
 			<object class="sizeritem">
 				<object class="wxFlexGridSizer" variable="FlexGridSizer4" member="no">
 					<cols>2</cols>
+					<growablecols>0</growablecols>
 					<object class="sizeritem">
 						<object class="wxSlider" name="ID_SLIDER_Ripple_XC" subclass="BulkEditSlider" variable="Slider_Ripple_XC" member="yes">
 							<min>-100</min>
@@ -345,6 +588,7 @@
 			<object class="sizeritem">
 				<object class="wxFlexGridSizer" variable="FlexGridSizer5" member="no">
 					<cols>2</cols>
+					<growablecols>0</growablecols>
 					<object class="sizeritem">
 						<object class="wxSlider" name="ID_SLIDER_Ripple_YC" subclass="BulkEditSlider" variable="Slider_Ripple_YC" member="yes">
 							<min>-100</min>
@@ -381,6 +625,164 @@
 				<border>5</border>
 				<option>1</option>
 			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT7" variable="StaticText8" member="yes">
+					<label>Velocity</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer9" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="IDD_SLIDER_Ripple_Velocity" subclass="BulkEditSliderF1" variable="Slider_Ripple_Velocity" member="yes">
+							<max>300</max>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Velocity" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_VelocityVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>5</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="ID_TEXTCTRL_Ripple_Velocity" subclass="BulkEditTextCtrlF1" variable="TextCtrl_Ripple_Velocity" member="yes">
+					<value>0.0</value>
+					<maxlength>4</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Velocity" subclass="xlLockButton" variable="BitmapButton_Ripple_Velocity" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT8" variable="StaticText9" member="yes">
+					<label>Direction</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxFlexGridSizer" variable="FlexGridSizer10" member="no">
+					<cols>2</cols>
+					<growablecols>0</growablecols>
+					<object class="sizeritem">
+						<object class="wxSlider" name="ID_SLIDER_Ripple_Direction" subclass="BulkEditSlider" variable="Slider_Ripple_Direction" member="yes">
+							<min>-360</min>
+							<max>360</max>
+						</object>
+						<flag>wxALL|wxEXPAND</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+					<object class="sizeritem">
+						<object class="wxBitmapButton" name="ID_VALUECURVE_Ripple_Direction" subclass="BulkEditValueCurveButton" variable="BitmapButton_Ripple_DirectionVC" member="yes">
+							<bitmap code="GetValueCurveNotSelectedBitmap()" />
+							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+						</object>
+						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+						<border>2</border>
+						<option>1</option>
+					</object>
+				</object>
+				<flag>wxALL|wxEXPAND</flag>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxTextCtrl" name="IDD_TEXTCTRL_Ripple_Direction" subclass="BulkEditTextCtrl" variable="TextCtrl_Ripple_Direction" member="yes">
+					<value>0</value>
+					<maxlength>3</maxlength>
+					<size>20,-1d</size>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_SLIDER_Ripple_Direction" subclass="xlLockButton" variable="BitmapButton_Ripple_Direction" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxStaticText" name="ID_STATICTEXT_Ripple_Draw_Style" variable="StaticText5" member="yes">
+					<label>Draw Style</label>
+				</object>
+				<flag>wxALL|wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxChoice" name="ID_CHOICE_Ripple_Draw_Style" subclass="BulkEditChoice" variable="Choice_Ripple_Draw_Style" member="yes">
+					<content>
+						<item>Old</item>
+						<item>Lines Inward</item>
+						<item>Lines Outward</item>
+						<item>Lines Both</item>
+						<item>Lines Inward Ripple</item>
+						<item>Lines Outward Ripple</item>
+						<item>Lines Both Ripple</item>
+						<item>Solid Inward</item>
+						<item>Solid Outward</item>
+						<item>Solid Both</item>
+						<item>Solid Inward Ripple</item>
+						<item>Solid Outward Ripple</item>
+						<item>Solid Both Ripple</item>
+						<item>Highlight Inward</item>
+						<item>Highlight Outward</item>
+						<item>Highlight Both</item>
+						<item>Highlight Inward Ripple</item>
+						<item>Highlight Outward Ripple</item>
+						<item>Highlight Both Ripple</item>
+					</content>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="spacer">
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>5</border>
+				<option>1</option>
+			</object>
+			<object class="sizeritem">
+				<object class="wxBitmapButton" name="ID_BITMAPBUTTON_CHOICE_Ripple_Draw_Style" subclass="xlLockButton" variable="BitmapButton_Ripple_Draw_Style" member="yes">
+					<size>14,14</size>
+					<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
+					<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
+				</object>
+				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
+				<border>1</border>
+				<option>1</option>
+			</object>
 			<object class="spacer">
 				<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
 				<border>5</border>
@@ -402,7 +804,6 @@
 							<size>14,14</size>
 							<bg>wxSYS_COLOUR_BTNHIGHLIGHT</bg>
 							<style>wxBU_AUTODRAW|wxBORDER_NONE</style>
-							<handler function="OnLockButtonClick" entry="EVT_BUTTON" />
 						</object>
 						<flag>wxALL|wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL</flag>
 						<border>1</border>
