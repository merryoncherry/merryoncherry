diff --git a/xLights/RenderBuffer.cpp b/xLights/RenderBuffer.cpp
index 813dbc425..1dddde3c3 100644
--- a/xLights/RenderBuffer.cpp
+++ b/xLights/RenderBuffer.cpp
@@ -895,36 +895,11 @@ float RenderBuffer::cos(float rad)
     return sinTable.cos(rad);
 }
 
-// generates a random number between num1 and num2 inclusive
-double RenderBuffer::RandomRange(double num1, double num2) const
-{
-    double hi,lo;
-    if (num1 < num2)
-    {
-        lo = num1;
-        hi = num2;
-    }
-    else
-    {
-        lo = num2;
-        hi = num1;
-    }
-    return rand01()*(hi-lo)+ lo;
-}
-
 void RenderBuffer::Color2HSV(const xlColor& color, HSVValue& hsv) const
 {
     color.toHSV(hsv);
 }
 
-// sets newcolor to a random color between hsv1 and hsv2
-void RenderBuffer::SetRangeColor(const HSVValue& hsv1, const HSVValue& hsv2, HSVValue& newhsv)
-{
-    newhsv.hue=RandomRange(hsv1.hue,hsv2.hue);
-    newhsv.saturation=RandomRange(hsv1.saturation,hsv2.saturation);
-    newhsv.value=1.0;
-}
-
 // return a value between c1 and c2
 uint8_t RenderBuffer::ChannelBlend(uint8_t c1, uint8_t c2, float ratio)
 {
diff --git a/xLights/RenderBuffer.h b/xLights/RenderBuffer.h
index 2573181ba..efe4ad6c2 100644
--- a/xLights/RenderBuffer.h
+++ b/xLights/RenderBuffer.h
@@ -435,6 +435,198 @@ public:
 	virtual ~EffectRenderCache();
 };
 
+class EffectRenderStatePRNG : public EffectRenderCache
+{
+public:
+    EffectRenderStatePRNG() :
+        EffectRenderCache()
+    {
+        xoroshiro_state[0] = 0xBAD5EED0DEADBEEFLLU;
+        xoroshiro_state[1] = 0xCAFECAFEBADC0DE2LLU;
+    }
+
+    /*  Written in 2016-2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)
+
+        To the extent possible under law, the author has dedicated all copyright
+        and related and neighboring rights to this software to the public domain
+        worldwide. This software is distributed without any warranty.
+        See <http://creativecommons.org/publicdomain/zero/1.0/>. */
+
+    /* For reference - see license and code at https://prng.di.unimi.it/xoroshiro128plus.c */
+    static inline uint64_t rotl(const uint64_t x, int k)
+    {
+        return (x << k) | (x >> (64 - k));
+    }
+
+    uint64_t xoroshiro_state[2];
+
+    uint64_t prngnext64(void)
+    {
+        const uint64_t s0 = xoroshiro_state[0];
+        uint64_t s1 = xoroshiro_state[1];
+        const uint64_t result = s0 + s1;
+
+        s1 ^= s0;
+        xoroshiro_state[0] = rotl(s0, 24) ^ s1 ^ (s1 << 16); // a, b
+        xoroshiro_state[1] = rotl(s1, 37);                   // c
+
+        return result;
+    }
+
+    uint32_t prngnext()
+    {
+        return uint32_t(prngnext64());
+    }
+
+    // Random int in the interval [0, mx)
+    uint64_t prngint64(uint64_t mx)
+    {
+        // TODO: This is not what they advise.  Can change.
+        return prngnext() % mx;
+    }
+
+    // Random int in the interval [0, mx)
+    int32_t prngint(uint32_t mx)
+    {
+        // This is not what they advise, should mx be a small power of 2.  Can change.
+        return prngnext() % mx;
+    }
+
+    // Random unsigned int in the interval [0, mx)
+    uint32_t prnguint(uint32_t mx)
+    {
+        // This is not what they advise, should mx be a small power of 2.  Can change.
+        return prngnext() % mx;
+    }
+
+    // Random boolean
+    bool prngbool(int pct_true = 50)
+    {
+        return prngint(100) < pct_true;
+    }
+    
+    // Random int in the closed interval [mn, mx]
+    int32_t prngintc(int32_t mn, int32_t mx)
+    {
+        return mn + prngint(uint32_t(mx - mn) + 1);
+    }
+
+    // Uniform [0-1]
+    double prnguniform64()
+    {
+        return double(prngnext()) / double(std::numeric_limits<uint64_t>::max());
+    }
+    double prnguniform()
+    {
+        return double(prngnext()) / double(std::numeric_limits<uint32_t>::max());
+    }
+
+    // Random double in the closed interval [mn, mx]
+    //  There is no obligation for mx > mn
+    double prngdc(double mn, double mx)
+    {
+        return prnguniform() * (mx - mn) + mn;
+    }
+
+    // sets newcolor to a random color between hsv1 and hsv2
+    void RandomColorInRange(const HSVValue& hsv1, const HSVValue& hsv2, HSVValue& newhsv)
+    {
+        newhsv.hue = prngdc(hsv1.hue, hsv2.hue);
+        newhsv.saturation = prngdc(hsv1.saturation, hsv2.saturation);
+        newhsv.value = 1.0;
+    }
+
+    /* This is the jump function for the generator. It is equivalent
+       to 2^64 calls to next(); it can be used to generate 2^64
+       non-overlapping subsequences for parallel computations. */
+
+    void jump(void)
+    {
+        static const uint64_t JUMP[] = { 0xdf900294d8f554a5, 0x170865df4b3201fc };
+
+        uint64_t s0 = 0;
+        uint64_t s1 = 0;
+        for (int i = 0; i < sizeof JUMP / sizeof *JUMP; i++)
+            for (int b = 0; b < 64; b++) {
+                if (JUMP[i] & UINT64_C(1) << b) {
+                    s0 ^= xoroshiro_state[0];
+                    s1 ^= xoroshiro_state[1];
+                }
+                prngnext();
+            }
+
+        xoroshiro_state[0] = s0;
+        xoroshiro_state[1] = s1;
+    }
+
+    /* This is the long-jump function for the generator. It is equivalent to
+       2^96 calls to next(); it can be used to generate 2^32 starting points,
+       from each of which jump() will generate 2^32 non-overlapping
+       subsequences for parallel distributed computations. */
+
+    void long_jump(void)
+    {
+        static const uint64_t LONG_JUMP[] = { 0xd2a98b26625eee7b, 0xdddf9b1090aa7ac1 };
+
+        uint64_t s0 = 0;
+        uint64_t s1 = 0;
+        for (int i = 0; i < sizeof LONG_JUMP / sizeof *LONG_JUMP; i++)
+            for (int b = 0; b < 64; b++) {
+                if (LONG_JUMP[i] & UINT64_C(1) << b) {
+                    s0 ^= xoroshiro_state[0];
+                    s1 ^= xoroshiro_state[1];
+                }
+                prngnext();
+            }
+
+        xoroshiro_state[0] = s0;
+        xoroshiro_state[1] = s1;
+    }
+
+    /*
+     * The PRNG should be seeded.  The idea here is that you might want it consistent though,
+     *   what should influence it?  In some cases, time would be good, but not some other times
+     */
+    void seedConsistently(uint64_t frame, uint64_t w, uint64_t h, const char* desc, uint64_t id)
+    {
+        xoroshiro_state[0] = 0xBAD5EED0DEADBEEFLLU;
+        xoroshiro_state[1] = 0xCAFECAFEBADC0DE2LLU;
+
+        xoroshiro_state[0] ^= (frame << 32) | (id);
+        xoroshiro_state[1] ^= (w << 32) | h;
+
+        if (desc) {
+            int l = strlen(desc);
+            int pl = l > 8 ? 8 : l;
+            for (int i = 0; i < pl; ++i) {
+                xoroshiro_state[0] ^= (desc[i] << (i * 8));
+            }
+            for (int i = 0; i < pl; ++i) {
+                xoroshiro_state[1] ^= ((desc[l - i - 1]) << (i*8));
+            }
+        }
+
+        prngnext();
+        prngnext();
+    }
+
+    /*
+     * The PRNG should be seeded.  The idea here is that you might want it consistent though,
+     *   what should influence it?  In some cases, time would be good, but not some other times
+     */
+    void seedConsistently(uint64_t v1, uint64_t v2, uint64_t v3, uint64_t v4)
+    {
+        xoroshiro_state[0] = 0xBAD5EED0DEADBEEFLLU;
+        xoroshiro_state[1] = 0xCAFECAFEBADC0DE2LLU;
+
+        xoroshiro_state[0] ^= (v1 << 32) | v2;
+        xoroshiro_state[1] ^= (v3 << 32) | v4;
+
+        prngnext();
+        prngnext();
+    }
+};
+
 class /*NCCDLLEXPORT*/ RenderBuffer {
 public:
     RenderBuffer(xLightsFrame *frame);
@@ -506,7 +698,6 @@ public:
     void Get2ColorAlphaBlend(const xlColor& c1, const xlColor& c2, float ratio, xlColor &color);
     void GetMultiColorBlend(float n, bool circular, xlColor &color, int reserveColors = 0);
     void SetRangeColor(const HSVValue& hsv1, const HSVValue& hsv2, HSVValue& newhsv);
-    double RandomRange(double num1, double num2) const;
     void Color2HSV(const xlColor& color, HSVValue& hsv) const;
     const PaletteClass& GetPalette() const { return palette; }
 
diff --git a/xLights/UtilFunctions.cpp b/xLights/UtilFunctions.cpp
index cfda90dbf..670365135 100644
--- a/xLights/UtilFunctions.cpp
+++ b/xLights/UtilFunctions.cpp
@@ -921,13 +921,6 @@ std::string BeforeInt(std::string& s)
     return res;
 }
 
-int intRand(const int& min, const int& max) {
-    static thread_local std::mt19937* generator = nullptr;
-    if (!generator) generator = new std::mt19937(clock() + std::hash<std::thread::id>{}(std::this_thread::get_id()));
-    std::uniform_int_distribution<int> distribution(min, max);
-    return distribution(*generator);
-}
-
 // Extract any leading number ... strip it from the input string
 int ExtractInt(std::string& s)
 {
diff --git a/xLights/UtilFunctions.h b/xLights/UtilFunctions.h
index aecbc1460..4229f4e0c 100644
--- a/xLights/UtilFunctions.h
+++ b/xLights/UtilFunctions.h
@@ -99,7 +99,6 @@ inline double rand01()
 
 void SaveWindowPosition(const std::string& tag, wxWindow* window);
 void LoadWindowPosition(const std::string& tag, wxSize& size, wxPoint& position);
-int intRand(const int& min, const int& max);
 int ExtractInt(std::string& s);
 void SaveInt(const std::string& tag, int value);
 int LoadInt(const std::string& tag, int defaultValue);
diff --git a/xLights/ValueCurve.h b/xLights/ValueCurve.h
index e60f33250..1cd29c679 100644
--- a/xLights/ValueCurve.h
+++ b/xLights/ValueCurve.h
@@ -147,9 +147,15 @@ public:
     float GetOutputValueAt(float offset, long startMS, long endMS);
     float GetOutputValueAtDivided(float offset, long startMS, long endMS);
     float GetScaledValue(float offset) const;
-    void SetActive(bool a) { _active = a; RenderType(); }
+    void SetActive(bool a) {
+        _active = a;
+        RenderType();
+    }
     bool IsActive() const { return _active && IsOk(); }
-    void ToggleActive() { _active = !_active; if (_active) RenderType(); }
+    void ToggleActive() {
+        _active = !_active;
+        if (_active) RenderType();
+    }
     void SetValueAt(float offset, float value);
     void DeletePoint(float offset);
     bool IsSetPoint(float offset);
diff --git a/xLights/effects/CandleEffect.cpp b/xLights/effects/CandleEffect.cpp
index 1d285892b..f8c26df42 100644
--- a/xLights/effects/CandleEffect.cpp
+++ b/xLights/effects/CandleEffect.cpp
@@ -61,7 +61,7 @@ struct CandleState
     wxByte flameg;
 };
 
-class CandleRenderCache : public EffectRenderCache
+class CandleRenderCache : public EffectRenderStatePRNG
 {
 public:
     std::map<int, CandleState*> _states;
@@ -85,6 +85,7 @@ static CandleRenderCache* GetCache(RenderBuffer& buffer, int id)
     if (cache == nullptr) {
         cache = new CandleRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     return cache;
 }
@@ -109,11 +110,11 @@ void CandleEffect::SetDefaultParameters()
     SetCheckBoxValue(fp->CheckBox_PerNode, false);
 }
 
-void CandleEffect::Update(wxByte& flameprime, wxByte& flame, wxByte& wind, size_t windVariability, size_t flameAgility, size_t windCalmness, size_t windBaseline)
+void CandleEffect::Update(EffectRenderStatePRNG* prng, wxByte& flameprime, wxByte& flame, wxByte& wind, size_t windVariability, size_t flameAgility, size_t windCalmness, size_t windBaseline)
 {
     // We simulate a gust of wind by setting the wind var to a random value
-    if (wxByte(rand01() * 255.0) < windVariability) {
-        wind = wxByte(rand01() * 255.0);
+    if (wxByte(prng->prnguniform() * 255.0) < windVariability) {
+        wind = wxByte(prng->prnguniform() * 255.0);
     }
 
     // The wind constantly settles towards its baseline value
@@ -128,8 +129,8 @@ void CandleEffect::Update(wxByte& flameprime, wxByte& flame, wxByte& wind, size_
 
     // Depending on the wind strength and the calmness modifier we calculate the odds
     // of the wind knocking down the flame by setting it to random values
-    if (wxByte(rand01() * 255) < (wind >> windCalmness)) {
-        flame = wxByte(rand01() * 255);
+    if (wxByte(prng->prnguniform() * 255) < (wind >> windCalmness)) {
+        flame = wxByte(prng->prnguniform() * 255);
     }
 
     // Real flames ook like they have inertia so we use this constant-aproach-rate filter
@@ -148,20 +149,20 @@ void CandleEffect::Update(wxByte& flameprime, wxByte& flame, wxByte& wind, size_
     // We don't. It adds to the realism.
 }
 
-void InitialiseState(int node, std::map<int, CandleState*>& states)
+void InitialiseState(CandleRenderCache *cache, int node, std::map<int, CandleState*>& states)
 {
     if (states.find(node) == states.end()) {
         CandleState* state = new CandleState();
         states[node] = state;
     }
 
-    states[node]->flamer = rand01() * 255;
-    states[node]->flameprimer = rand01() * 255;
+    states[node]->flamer = cache->prngint(255); // Could be 256 but 255 closely follows the original code
+    states[node]->flameprimer = cache->prngint(255);
 
-    states[node]->flameg = rand01() * states[node]->flamer;
-    states[node]->flameprimeg = rand01() * states[node]->flameprimer;
+    states[node]->flameg = cache->prnguniform() * states[node]->flamer;
+    states[node]->flameprimeg = cache->prnguniform() * states[node]->flameprimer;
 
-    states[node]->wind = rand01() * 255;
+    states[node]->wind = cache->prnguniform() * 255;
 }
 
 // 10 <= HeightPct <= 100
@@ -188,17 +189,20 @@ void CandleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
             for (size_t x = 0; x < maxMWi; ++x) {
                 for (size_t y = 0; y < maxMHt; ++y) {
                     size_t index = y * maxMWi + x;
-                    InitialiseState(index, states);
+                    InitialiseState(cache, index, states);
                 }
             }
         } else {
-            InitialiseState(0, states);
+            InitialiseState(cache, 0, states);
         }
     }
 
     if (perNode) {
         int maxW = cache->maxWid;
         parallel_for(0, buffer.BufferHt, [&buffer, &states, maxW, windVariability, flameAgility, windCalmness, windBaseline, this](int y) {
+            EffectRenderStatePRNG prng;
+            prng.seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), y);
+            prng.prngnext();
             for (size_t x = 0; x < buffer.BufferWi; x++) {
                 size_t index = y * maxW + x;
                 if (index >= states.size()) {
@@ -207,8 +211,8 @@ void CandleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
                 } else {
                     CandleState* state = states[index];
 
-                    Update(state->flameprimer, state->flamer, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
-                    Update(state->flameprimeg, state->flameg, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
+                    Update(&prng, state->flameprimer, state->flamer, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
+                    Update(&prng, state->flameprimeg, state->flameg, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
 
                     if (state->flameprimeg > state->flameprimer)
                         state->flameprimeg = state->flameprimer;
@@ -224,8 +228,8 @@ void CandleEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
     } else {
         CandleState* state = states[0];
 
-        Update(state->flameprimer, state->flamer, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
-        Update(state->flameprimeg, state->flameg, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
+        Update(cache, state->flameprimer, state->flamer, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
+        Update(cache, state->flameprimeg, state->flameg, state->wind, windVariability, flameAgility, windCalmness, windBaseline);
 
         if (state->flameprimeg > state->flameprimer)
             state->flameprimeg = state->flameprimer;
diff --git a/xLights/effects/CandleEffect.h b/xLights/effects/CandleEffect.h
index 3ed72ed52..18e176369 100644
--- a/xLights/effects/CandleEffect.h
+++ b/xLights/effects/CandleEffect.h
@@ -24,6 +24,8 @@
 #define CANDLE_WINDCALMNESS_MIN 0
 #define CANDLE_WINDCALMNESS_MAX 10
 
+class EffectRenderStatePRNG;
+
 class CandleEffect : public RenderableEffect
 {
 public:
@@ -60,5 +62,5 @@ public:
 
 protected:
     virtual xlEffectPanel* CreatePanel(wxWindow* parent) override;
-    void Update(wxByte& flameprime, wxByte& flame, wxByte& wind, size_t windVariability, size_t flameAgility, size_t windCalmness, size_t windBaseline);
+    void Update(EffectRenderStatePRNG *prng, wxByte& flameprime, wxByte& flame, wxByte& wind, size_t windVariability, size_t flameAgility, size_t windCalmness, size_t windBaseline);
 };
diff --git a/xLights/effects/CirclesEffect.cpp b/xLights/effects/CirclesEffect.cpp
index 300784a7b..fae506635 100644
--- a/xLights/effects/CirclesEffect.cpp
+++ b/xLights/effects/CirclesEffect.cpp
@@ -108,7 +108,6 @@ class MetaBall : public RgbBalls
 public:
     float Equation(float x, float y)
     {
-        //            if(x==_x || y==_y) return 1; //this is incorrect
         if ((x == _x) && (y == _y)) return 1; //only return 1 if *both* coordinates match; else gives extraneous horiz or vert lines -DJ
         return (_radius / (sqrt(pow(x - _x, 2) + pow(y - _y, 2))));
     }
@@ -116,7 +115,7 @@ public:
 
 static const int MAX_RGB_BALLS = 20;
 
-class CirclesRenderCache : public EffectRenderCache {
+class CirclesRenderCache : public EffectRenderStatePRNG {
 public:
     CirclesRenderCache() : numBalls(0), metaType(false) {
         balls = new RgbBalls[MAX_RGB_BALLS];
@@ -178,6 +177,7 @@ void CirclesEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
     if (cache == nullptr) {
         cache = new CirclesRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
 
     size_t colorCnt = buffer.GetColorCount();
@@ -196,6 +196,9 @@ void CirclesEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
 
     if (buffer.needToInit || radius != effectObjects[0]._radius || number != cache->numBalls || cache->metaType != plasma)
     {
+        if (buffer.needToInit) {
+            cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+        }
         for (int ii = 0; ii < number; ii++)
         {
             int colorIdx = 0;
@@ -203,11 +206,11 @@ void CirclesEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
             float spd;
             if (ii >= cache->numBalls || buffer.needToInit)
             {
-                start_x = rand() % (buffer.BufferWi);
-                start_y = rand() % (buffer.BufferHt);
+                start_x = cache->prngint(buffer.BufferWi);
+                start_y = cache->prngint(buffer.BufferHt);
                 colorIdx = ii % colorCnt;
-                angle = rand() % 2 ? rand() % 90 : -rand() % 90;
-                spd = rand() % 3 + 1;
+                angle = cache->prngbool() ? cache->prngint(90) : -cache->prngint(90);
+                spd = cache->prngint(3) + 1;
             }
             else
             {
@@ -220,8 +223,7 @@ void CirclesEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
             effectObjects[ii].Reset((float)start_x, (float)start_y, spd, angle, (float)radius, colorIdx);
             if (bubbles) //keep bubbles going mostly up
             {
-                // This looks odd ... rand() is 0-1 so % 45 is going to be rand()
-                angle = 90 + rand() % 45 - 22.5f; //+/- 22.5 degrees from 90 degrees
+                angle = 90 + cache->prngint(45) - 22.5f; //+/- 22.5 degrees from 90 degrees
                 angle *= 2.0f * (float)M_PI / 180.0f;
                 effectObjects[ii]._dx = spd * cos(angle);
                 effectObjects[ii]._dy = spd * sin(angle);
diff --git a/xLights/effects/FacesEffect.cpp b/xLights/effects/FacesEffect.cpp
index 662f2132a..3b61d68c4 100644
--- a/xLights/effects/FacesEffect.cpp
+++ b/xLights/effects/FacesEffect.cpp
@@ -30,7 +30,7 @@
 
 #include <log4cpp/Category.hh>
 
-class FacesRenderCache : public EffectRenderCache {
+class FacesRenderCache : public EffectRenderStatePRNG {
     std::map<std::string, RenderBuffer*> _imageCache;
 
 public:
@@ -39,7 +39,7 @@ public:
     std::map<std::string, int> nodeNameCache;
 
     FacesRenderCache() :
-        blinkEndTime(0), nextBlinkTime(intRand(0, 5000)) {
+        blinkEndTime(0), nextBlinkTime(0) {
     }
     virtual ~FacesRenderCache() {
         for (auto it : _imageCache) {
@@ -679,6 +679,8 @@ void FacesEffect::drawoutline(RenderBuffer& buffer, int Phoneme, bool outline, c
     if (cache == nullptr) {
         cache = new FacesRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+        cache->nextBlinkTime = cache->prngintc(0, 5000);
     }
 
     int Ht = BufferHt - 1;
@@ -696,7 +698,7 @@ void FacesEffect::drawoutline(RenderBuffer& buffer, int Phoneme, bool outline, c
         if (Phoneme == 9 || Phoneme == 10) {
             if ((buffer.curPeriod * buffer.frameTimeInMs) >= cache->nextBlinkTime) {
                 //roughly every 5 seconds we'll blink
-                cache->nextBlinkTime += intRand(4500, 5500);
+                cache->nextBlinkTime += cache->prngintc(4500, 5500);
                 cache->blinkEndTime = buffer.curPeriod * buffer.frameTimeInMs + 101; //100ms blink
                 eye = "Closed";
             } else if ((buffer.curPeriod * buffer.frameTimeInMs) < cache->blinkEndTime) {
@@ -999,7 +1001,7 @@ void FacesEffect::RenderFaces(RenderBuffer& buffer,
             if ("Auto" == eyes) {
                 if ((buffer.curPeriod * buffer.frameTimeInMs) >= cache->nextBlinkTime) {
                     // roughly every 5 seconds we'll blink
-                    cache->nextBlinkTime += intRand(4500, 5500);
+                    cache->nextBlinkTime += cache->prngintc(4500, 5500);
                     cache->blinkEndTime = buffer.curPeriod * buffer.frameTimeInMs + 101; // 100ms blink
                     eyes = "Closed";
                 } else if ((buffer.curPeriod * buffer.frameTimeInMs) < cache->blinkEndTime) {
@@ -1050,7 +1052,7 @@ void FacesEffect::RenderFaces(RenderBuffer& buffer,
                     if ((buffer.curPeriod * buffer.frameTimeInMs) >= cache->nextBlinkTime) {
                         if ((startms + 150) >= (buffer.curPeriod * buffer.frameTimeInMs)) {
                             // don't want to blink RIGHT at the start of the rest, delay a little bie
-                            int tmp = (buffer.curPeriod * buffer.frameTimeInMs) + intRand(150, 549);
+                            int tmp = (buffer.curPeriod * buffer.frameTimeInMs) + cache->prngintc(150, 549);
 
                             // also don't want it right at the end
                             if ((tmp + 130) > endms) {
@@ -1060,7 +1062,7 @@ void FacesEffect::RenderFaces(RenderBuffer& buffer,
                             }
                         } else {
                             // roughly every 5 seconds we'll blink
-                            cache->nextBlinkTime += intRand(4500, 5500);
+                            cache->nextBlinkTime += cache->prngintc(4500, 5500);
                             cache->blinkEndTime = buffer.curPeriod * buffer.frameTimeInMs + 101; // 100ms blink
                             eyes = "Closed";
                         }
@@ -1076,7 +1078,7 @@ void FacesEffect::RenderFaces(RenderBuffer& buffer,
             if ("Auto" == eyes) {
                 if ((buffer.curPeriod * buffer.frameTimeInMs) >= cache->nextBlinkTime) {
                     // roughly every 5 seconds we'll blink
-                    cache->nextBlinkTime += intRand(4500, 5500);
+                    cache->nextBlinkTime += cache->prngintc(4500, 5500);
                     cache->blinkEndTime = buffer.curPeriod * buffer.frameTimeInMs + 101; // 100ms blink
                     eyes = "Closed";
                 } else if ((buffer.curPeriod * buffer.frameTimeInMs) < cache->blinkEndTime) {
diff --git a/xLights/effects/FireEffect.cpp b/xLights/effects/FireEffect.cpp
index 68934c10e..fa8bd9b49 100644
--- a/xLights/effects/FireEffect.cpp
+++ b/xLights/effects/FireEffect.cpp
@@ -152,7 +152,8 @@ static int GetLocation(const std::string &location) {
 
 
 
-class FireRenderCache : public EffectRenderCache {
+class FireRenderCache : public EffectRenderStatePRNG
+{
 public:
     FireRenderCache() {};
     virtual ~FireRenderCache() {};
@@ -243,6 +244,7 @@ void FireEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
     float mod_state = 4.0;
     if (buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         cache->FireBuffer.resize(maxMHt * maxMWi);
         for (size_t i = 0; i < cache->FireBuffer.size(); ++i) {
             cache->FireBuffer[i] = 0;
@@ -252,7 +254,7 @@ void FireEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
     }
     // build fire
     for (int x = 0; x < maxMWi; ++x) {
-        int r = x % 2 == 0 ? 190 + (rand() % 10) : 100 + (rand() % 50);
+        int r = x % 2 == 0 ? 190 + (cache->prngint(10)) : 100 + (cache->prngint(50));
         SetFireBuffer(x, 0, r, cache->FireBuffer, maxMWi, maxMHt);
     }
     int step = 255 * 100 / maxHt / HeightPct;
@@ -282,7 +284,7 @@ void FireEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
             }
             int new_index = n > 0 ? sum / n : 0;
             if (new_index > 0) {
-                new_index += (rand() % 100 < 20) ? step : -step;
+                new_index += (cache->prngint(100) < 20) ? step : -step;
                 if (new_index < 0)
                     new_index = 0;
                 if (new_index >= FirePalette.size())
diff --git a/xLights/effects/FireworksEffect.cpp b/xLights/effects/FireworksEffect.cpp
index 2b522d2d5..dff714e5c 100644
--- a/xLights/effects/FireworksEffect.cpp
+++ b/xLights/effects/FireworksEffect.cpp
@@ -74,7 +74,8 @@ class FireworkParticle
     int _age = 0;
 
 public:
-    FireworkParticle(int x, int y, double vx, double vy, int fade, bool gravity, int colourIndex, bool holdColour, double velocity, int width, int height, int frameMS, const PaletteClass& palette)
+    FireworkParticle(int x, int y, double vx, double vy, int fade, bool gravity, int colourIndex, bool holdColour, double velocity, int width, int height,
+                     int frameMS, const PaletteClass& palette, EffectRenderStatePRNG *prng)
     {
         _width = width;
         _height = height;
@@ -92,8 +93,8 @@ public:
 
         _fps = 1000.0 / frameMS;
 
-        double explosionVelocity = (rand() - RAND_MAX / 2)*velocity / (RAND_MAX / 2);
-        double angle = 2 * M_PI*rand() / RAND_MAX;
+        double explosionVelocity = (prng->prnguniform() * 2 - 1)*velocity;
+        double angle = 2 * M_PI * prng->prnguniform();
         _vx = 3.0 * vx / 100 + explosionVelocity * cos(angle);
         _vy = 3.0 * -vy / 100 + explosionVelocity * sin(angle);
     }
@@ -165,12 +166,13 @@ class Firework
     std::vector<FireworkParticle> _particles;
 
 public:
-    Firework(int particles, int x, int y, double vx, double vy, int fade, bool gravity, int colourIndex, bool holdColour, double velocity, int width, int height, int frameMS, const PaletteClass& palette)
+    Firework(int particles, int x, int y, double vx, double vy, int fade, bool gravity, int colourIndex, bool holdColour, double velocity,
+             int width, int height, int frameMS, const PaletteClass& palette, EffectRenderStatePRNG *prng)
     {
         _cycles = 0;
         for (int i = 0; i < particles; i++)
         {
-            _particles.push_back(FireworkParticle(x, y, vx, vy, fade, gravity, colourIndex, holdColour, velocity, width, height, frameMS, palette));
+            _particles.push_back(FireworkParticle(x, y, vx, vy, fade, gravity, colourIndex, holdColour, velocity, width, height, frameMS, palette, prng));
         }
     }
 
@@ -207,7 +209,7 @@ public:
     }
 };
 
-class FireworksRenderCache : public EffectRenderCache {
+class FireworksRenderCache : public EffectRenderStatePRNG {
 public:
     FireworksRenderCache() {};
     virtual ~FireworksRenderCache() {};
@@ -305,7 +307,7 @@ void FireworksEffect::SetPanelTimingTracks() const
     wxPostEvent(fp, event);
 }
 
-std::pair<int,int> FireworksEffect::GetFireworkLocation(int width, int height, int overridex, int overridey)
+std::pair<int,int> GetFireworkLocation(int width, int height, int overridex, int overridey, EffectRenderStatePRNG *prng)
 {
     int startX;
     int startY;
@@ -317,7 +319,7 @@ std::pair<int,int> FireworksEffect::GetFireworkLocation(int width, int height, i
     {
         int x25 = static_cast<int>(0.25f * width);
         int x75 = static_cast<int>(0.75f * width);
-        if ((x75 - x25) > 0) startX = x25 + rand() % (x75 - x25); else startX = 0;
+        if ((x75 - x25) > 0) startX = x25 + prng->prngint(x75 - x25); else startX = 0;
     }
 
     if (overridey >= 0)
@@ -328,7 +330,7 @@ std::pair<int,int> FireworksEffect::GetFireworkLocation(int width, int height, i
     {
         int y25 = static_cast<int>(0.25f * height);
         int y75 = static_cast<int>(0.75f * height);
-        if ((y75 - y25) > 0) startY = y25 + rand() % (y75 - y25); else startY = 0;
+        if ((y75 - y25) > 0) startY = y25 + prng->prngint(y75 - y25); else startY = 0;
     }
     return { startX, startY };
 }
@@ -381,12 +383,13 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
 
     if (buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         SetPanelTimingTracks();
         sinceLastTriggered = 0;
         if (!useMusic && !useTiming)
         {
             for (int i = 0; i < numberOfExplosions; i++) {
-                firePeriods.push_back(buffer.curEffStartPer + rand01() * (buffer.curEffEndPer - buffer.curEffStartPer));
+                firePeriods.push_back(buffer.curEffStartPer + cache->prnguniform() * (buffer.curEffEndPer - buffer.curEffStartPer));
             }
         }
 
@@ -404,8 +407,8 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
             // trigger if it was not previously triggered or has been triggered for REPEATTRIGGER frames
             if (sinceLastTriggered == 0 || sinceLastTriggered > REPEATTRIGGER)
             {
-                auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation);
-                int colourIndex = rand() % colorcnt;
+                auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation, cache);
+                int colourIndex = cache->prngint(colorcnt);
                 fireworks.push_back(Firework(particleCount,
                     location.first, location.second,
                     xVelocity, yVelocity,
@@ -413,7 +416,7 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
                     colourIndex, holdColour,
                     particleVelocity,
                     buffer.BufferWi, buffer.BufferHt,
-                    buffer.frameTimeInMs, buffer.palette));
+                    buffer.frameTimeInMs, buffer.palette, cache));
             }
 
             // if music is over the trigger level for REPEATTRIGGER frames then we will trigger another firework
@@ -453,8 +456,8 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
                     if (buffer.curPeriod == el->GetEffect(j)->GetStartTimeMS() / buffer.frameTimeInMs ||
                         buffer.curPeriod == el->GetEffect(j)->GetEndTimeMS() / buffer.frameTimeInMs)
                     {
-                        auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation);
-                        int colourIndex = rand() % colorcnt;
+                        auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation, cache);
+                        int colourIndex = cache->prngint(colorcnt);
                         fireworks.push_back(Firework(particleCount,
                             location.first, location.second,
                             xVelocity, yVelocity,
@@ -462,7 +465,7 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
                             colourIndex, holdColour,
                             particleVelocity,
                             buffer.BufferWi, buffer.BufferHt,
-                            buffer.frameTimeInMs, buffer.palette));
+                            buffer.frameTimeInMs, buffer.palette, cache));
                         break;
                     }
                 }
@@ -476,8 +479,8 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
         {
             if (it == buffer.curPeriod)
             {
-                auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation);
-                int colourIndex = rand() % colorcnt;
+                auto location = GetFireworkLocation(buffer.BufferWi, buffer.BufferHt, xLocation, yLocation, cache);
+                int colourIndex = cache->prngint(colorcnt);
                 fireworks.push_back(Firework(particleCount,
                     location.first, location.second,
                     xVelocity, yVelocity,
@@ -485,7 +488,7 @@ void FireworksEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
                     colourIndex, holdColour,
                     particleVelocity,
                     buffer.BufferWi, buffer.BufferHt,
-                    buffer.frameTimeInMs, buffer.palette));
+                    buffer.frameTimeInMs, buffer.palette, cache));
             }
         }
     }
diff --git a/xLights/effects/FireworksEffect.h b/xLights/effects/FireworksEffect.h
index ed36b34c1..b63c1b3e3 100644
--- a/xLights/effects/FireworksEffect.h
+++ b/xLights/effects/FireworksEffect.h
@@ -89,7 +89,6 @@ public:
 protected:
     virtual xlEffectPanel* CreatePanel(wxWindow* parent) override;
     void SetPanelTimingTracks() const;
-    static std::pair<int, int> GetFireworkLocation(int width, int height, int overridex = -1, int overridey = -1);
     virtual bool needToAdjustSettings(const std::string& version) override;
     virtual void adjustSettings(const std::string& version, Effect* effect, bool removeDefaults = true) override;
 };
diff --git a/xLights/effects/KaleidoscopeEffect.cpp b/xLights/effects/KaleidoscopeEffect.cpp
index 559d3f376..49e78e9e1 100644
--- a/xLights/effects/KaleidoscopeEffect.cpp
+++ b/xLights/effects/KaleidoscopeEffect.cpp
@@ -392,7 +392,8 @@ void KaleidoscopeEffect::Render(Effect *eff, const SettingsMap &SettingsMap, Ren
         //int set = 0;
 
         //DumpUsed(currentUsed, buffer.BufferWi, buffer.BufferHt);
-        parallel_for(0, buffer.BufferHt, [&currentUsed, this, &buffer, &edge, &setSinceBegin] (int y) {
+        auto nextUsed = currentUsed;
+        parallel_for(0, buffer.BufferHt, [&currentUsed, &nextUsed, this, &buffer, &edge, &setSinceBegin] (int y) {
             for (int x = 0; x < buffer.BufferWi; x++) {
                 if (!currentUsed[x][y]) {
                     // this pixel needs to be set
@@ -400,14 +401,16 @@ void KaleidoscopeEffect::Render(Effect *eff, const SettingsMap &SettingsMap, Ren
                     if (source.first >= 0 && source.first < buffer.BufferWi && source.second >= 0 && source.second < buffer.BufferHt) {
                         if (currentUsed[source.first][source.second]) {
                             buffer.SetPixel(x, y, buffer.GetPixel(source.first, source.second));
-                            currentUsed[x][y] = true;
+                            nextUsed[x][y] = true;
                             //set++;
                             setSinceBegin++;
                         }
                     }
                 }
             }
-        });
+        }, 999999999);
+        currentUsed = nextUsed;
+
         //logger_base.debug("   set this iteration %d", set);
         ++edge;
         if (edge == edges.end()) {
diff --git a/xLights/effects/LifeEffect.cpp b/xLights/effects/LifeEffect.cpp
index 5954de708..e96d2a259 100644
--- a/xLights/effects/LifeEffect.cpp
+++ b/xLights/effects/LifeEffect.cpp
@@ -58,7 +58,7 @@ static size_t Life_CountNeighbors(RenderBuffer& buffer, int x0, int y0)
     return cnt;
 }
 
-class LifeRenderCache : public EffectRenderCache {
+class LifeRenderCache : public EffectRenderStatePRNG {
 public:
     LifeRenderCache() : LastLifeCount(0), LastLifeType(0), LastLifeState(0) {};
     virtual ~LifeRenderCache() {};
@@ -88,6 +88,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
     if (cache == nullptr) {
         cache = new LifeRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
 
     int i, x, y, cnt;
@@ -102,14 +103,15 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
     Count = BufferWi * BufferHt * Count / 200 + 1;
     if (buffer.needToInit || Count != cache->LastLifeCount || Type != cache->LastLifeType) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         // seed tempbuf
         cache->LastLifeCount = Count;
         cache->LastLifeType = Type;
         buffer.ClearTempBuf();
         for (i = 0; i < Count; i++) {
-            x = rand() % BufferWi;
-            y = rand() % BufferHt;
-            buffer.GetMultiColorBlend(rand01(), false, color);
+            x = cache->prngint(BufferWi);
+            y = cache->prngint(BufferHt);
+            buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
             buffer.SetTempPixel(x, y, color);
         }
     }
@@ -139,7 +141,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
                 if (isLive && cnt >= 2 && cnt <= 3) {
                     buffer.SetPixel(x, y, color);
                 } else if (!isLive && cnt == 3) {
-                    buffer.GetMultiColorBlend(rand01(), false, color);
+                    buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
                     buffer.SetPixel(x, y, color);
                 }
                 break;
@@ -148,7 +150,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
                 if (isLive && (cnt == 2 || cnt == 3 || cnt == 6)) {
                     buffer.SetPixel(x, y, color);
                 } else if (!isLive && (cnt == 3 || cnt == 5)) {
-                    buffer.GetMultiColorBlend(rand01(), false, color);
+                    buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
                     buffer.SetPixel(x, y, color);
                 }
                 break;
@@ -157,7 +159,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
                 if (isLive && (cnt == 1 || cnt == 3 || cnt == 5 || cnt == 8)) {
                     buffer.SetPixel(x, y, color);
                 } else if (!isLive && (cnt == 3 || cnt == 5 || cnt == 7)) {
-                    buffer.GetMultiColorBlend(rand01(), false, color);
+                    buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
                     buffer.SetPixel(x, y, color);
                 }
                 break;
@@ -166,7 +168,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
                 if (isLive && (cnt == 2 || cnt == 3 || cnt >= 5)) {
                     buffer.SetPixel(x, y, color);
                 } else if (!isLive && (cnt == 3 || cnt == 7 || cnt == 8)) {
-                    buffer.GetMultiColorBlend(rand01(), false, color);
+                    buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
                     buffer.SetPixel(x, y, color);
                 }
                 break;
@@ -175,7 +177,7 @@ void LifeEffect::Render(Effect* effect, const SettingsMap& SettingsMap, RenderBu
                 if (isLive && (cnt >= 5)) {
                     buffer.SetPixel(x, y, color);
                 } else if (!isLive && (cnt == 2 || cnt >= 5)) {
-                    buffer.GetMultiColorBlend(rand01(), false, color);
+                    buffer.GetMultiColorBlend(cache->prnguniform(), false, color);
                     buffer.SetPixel(x, y, color);
                 }
                 break;
diff --git a/xLights/effects/LightningEffect.cpp b/xLights/effects/LightningEffect.cpp
index f6fb64e65..9fa039863 100644
--- a/xLights/effects/LightningEffect.cpp
+++ b/xLights/effects/LightningEffect.cpp
@@ -88,6 +88,12 @@ void LightningEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
     //int botY = SettingsMap.GetInt("SLIDER_Lightning_BOTY", 0);
     int DIRECTION = GetLightningEffect(SettingsMap["CHOICE_Lightning_Direction"]);
 
+    EffectRenderStatePRNG prng;
+    prng.seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+    prng.prngnext(); // Seed is very close by, doing this just in case, but never checked if it's really a concern
+    prng.prngnext();
+    prng.prngnext();
+
     if (Number_Bolts == 0) {
         Number_Bolts = 1;
     }
@@ -118,17 +124,17 @@ void LightningEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
 
     int xoffset = curState * botX / 10.0;
     for(int i = 0; i <= segment; i++) {
-        int j = rand() + 1;
+        int j = prng.prngint(2000000000) + 1;
         int x2 = 0;
         int y2 = 0;
         if(DIRECTION==UP || DIRECTION==DOWN) {
             if(i % 2 == 0) { // Every even segment will alternate direction
-                if (rand() % 2 == 0) // target x is to the left
+                if (!prng.prngbool()) // target x is to the left
                     x2 = xc + topX - (j % Number_Segments);
-                else // but randomely we reverse direction, also make it a larger jag
+                else // but randomly we reverse direction, also make it a larger jag
                     x2 = xc + topX + (2 * (j % Number_Segments));
             } else { // odd segments will
-                if (rand() % 2 == 0) // move to the right
+                if (!prng.prngbool()) // move to the right
                     x2 = xc + topX + (j % Number_Segments);
                 else // but sometimes move 3 units to left.
                     x2 = xc + topX - (3 * (j % Number_Segments));
@@ -148,11 +154,11 @@ void LightningEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Ren
             if (i > (segment / 2)) {
                 int x3 = 0;
                 if (i % 2 == 1) {
-                    if (rand()%2==1)
+                    if (prng.prngbool())
                         x3 = xc + topX - (j % Number_Segments);
                     else  x3 = xc + topX + (2 * (j % Number_Segments));
                 } else {
-                    if (rand() % 2 == 1)
+                    if (prng.prngbool())
                         x3 = xc + topX + (j % Number_Segments);
                     else
                         x3 = xc + topX - (3 * (j % Number_Segments));
diff --git a/xLights/effects/LinesEffect.cpp b/xLights/effects/LinesEffect.cpp
index f6ef9b2ce..75a5ccfd5 100644
--- a/xLights/effects/LinesEffect.cpp
+++ b/xLights/effects/LinesEffect.cpp
@@ -90,12 +90,12 @@ class LineObject
 {
     std::list<std::list<LinePoint>> _points;
 
-    static LinePoint CreatePoint(int width, int height)
+    static LinePoint CreatePoint(EffectRenderStatePRNG *cache, int width, int height)
     {
         LinePoint pt;
-        pt._x = rand01() * width;
-        pt._y = rand01() * height;
-        pt._angle = rand01() * pi2;
+        pt._x = cache->prngint(width);
+        pt._y = cache->prngint(height);
+        pt._angle = cache->prnguniform() * pi2;
         return pt;
     }
 
@@ -117,13 +117,13 @@ class LineObject
     }
 
 public:
-    void CreateFirst(int points, int width, int height)
+    void CreateFirst(EffectRenderStatePRNG* cache, int points, int width, int height)
     {
         if (_points.size() != 0) return;
 
         std::list<LinePoint> pts;
         while (pts.size() < points) {
-            pts.push_back(CreatePoint(width, height));
+            pts.push_back(CreatePoint(cache, width, height));
         }
         _points.push_back(std::move(pts));
     }
@@ -182,7 +182,7 @@ public:
     }
 };
 
-class LinesRenderCache : public EffectRenderCache
+class LinesRenderCache : public EffectRenderStatePRNG
 {
 
 public:
@@ -202,7 +202,7 @@ public:
         }
         while (_lineObjects.size() < objects) {
             LineObject line;
-            line.CreateFirst(points, width, height);
+            line.CreateFirst(this, points, width, height);
             _lineObjects.push_back(std::move(line));
         }
     }
@@ -215,6 +215,7 @@ void LinesEffect::Render(RenderBuffer &buffer, int objects, int points, int thic
 	if (cache == nullptr) {
 		cache = new LinesRenderCache();
 		buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
 	}
 
     auto& _lines = cache->_lineObjects;
@@ -222,6 +223,7 @@ void LinesEffect::Render(RenderBuffer &buffer, int objects, int points, int thic
 	// Check for config changes which require us to reset
 	if (buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
 	}
 
     cache->CreateDestroy(objects, points, buffer.BufferWi, buffer.BufferHt);
diff --git a/xLights/effects/LiquidEffect.cpp b/xLights/effects/LiquidEffect.cpp
index 980021b50..6181eab85 100644
--- a/xLights/effects/LiquidEffect.cpp
+++ b/xLights/effects/LiquidEffect.cpp
@@ -200,7 +200,7 @@ void LiquidEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Render
         );
 }
 
-class LiquidRenderCache : public EffectRenderCache {
+class LiquidRenderCache : public EffectRenderStatePRNG {
 public:
     LiquidRenderCache() { _world = nullptr; };
     virtual ~LiquidRenderCache() {
@@ -386,7 +386,8 @@ xlColor LiquidEffect::GetDespeckleColor(RenderBuffer& buffer, size_t x, size_t y
     return xlColor(red / count, green / count, blue / count);
 }
 
-void LiquidEffect::CreateParticles(b2ParticleSystem* ps, int x, int y, int direction, int velocity, int flow, bool flowMusic, int lifetime, int width, int height, const xlColor& c, const std::string& particleType, bool mixcolors, float audioLevel, int sourceSize)
+void LiquidEffect::CreateParticles(EffectRenderStatePRNG *cache, b2ParticleSystem* ps, int x, int y, int direction, int velocity, int flow, bool flowMusic,
+    int lifetime, int width, int height, const xlColor& c, const std::string& particleType, bool mixcolors, float audioLevel, int sourceSize)
 {
     static const float pi2 = 6.283185307f;
     float posx = (float)x * (float)width / 100.0;
@@ -395,7 +396,7 @@ void LiquidEffect::CreateParticles(b2ParticleSystem* ps, int x, int y, int direc
     float velx = (float)velocity * 10.0 * RenderBuffer::cos(pi2 * (float)direction / 360.0);
     float vely = (float)velocity * 10.0 * RenderBuffer::sin(pi2 * (float)direction / 360.0);
 
-    float velVariation = rand01() * 0.1;
+    float velVariation = cache->prnguniform() * 0.1;
     velVariation -= velVariation / 2.0;
 
     velx -= velx * velVariation;
@@ -459,10 +460,10 @@ void LiquidEffect::CreateParticles(b2ParticleSystem* ps, int x, int y, int direc
         if (sourceSize == 0)
         {
             // Randomly pick a position within the emitter's radius.
-            const float32 angle = rand01() * 2.0f * b2_pi;
+            const float32 angle = cache->prnguniform() * 2.0f * b2_pi;
 
             // Distance from the center of the circle.
-            const float32 distance = rand01();
+            const float32 distance = cache->prnguniform();
             b2Vec2 positionOnUnitCircle(RenderBuffer::sin(angle), RenderBuffer::cos(angle));
 
             // Initial position.
@@ -473,7 +474,7 @@ void LiquidEffect::CreateParticles(b2ParticleSystem* ps, int x, int y, int direc
         else
         {
             // Distance from the center of the circle.
-            const float32 distance = rand01() * ((float)sourceSize - (float)sourceSize / 2.0);
+            const float32 distance = cache->prnguniform() * ((float)sourceSize - (float)sourceSize / 2.0);
 
             float offx = distance * RenderBuffer::cos(pi2 * ((float)direction + 90.0) / 360.0);
             float offy = distance * RenderBuffer::sin(pi2 * ((float)direction + 90.0) / 360.0);
@@ -489,7 +490,7 @@ void LiquidEffect::CreateParticles(b2ParticleSystem* ps, int x, int y, int direc
         // give it a lifetime
         if (lifetime > 0)
         {
-            float randomlt = lt + (lt * 0.2 * rand01()) - (lt *.01);
+            float randomlt = lt + (lt * 0.2 * cache->prnguniform()) - (lt *.01);
             pd.lifetime = randomlt;
         }
         ps->CreateParticle(pd);
@@ -515,6 +516,8 @@ void LiquidEffect::Step(b2World* world, RenderBuffer &buffer, bool enabled[], in
     int x4, int y4, int direction4, int velocity4, int flow4, int sourceSize4, bool flowMusic4, float time
 )
 {
+    LiquidRenderCache* cache = (LiquidRenderCache*)buffer.infoCache[id];
+
     // move all existing items
     float32 timeStep = (float)buffer.frameTimeInMs / 1000.0;
     int32 velocityIterations = 6;
@@ -547,16 +550,16 @@ void LiquidEffect::Step(b2World* world, RenderBuffer &buffer, bool enabled[], in
                 switch (i)
                 {
                 case 0:
-                    CreateParticles(ps, x1, y1, direction1, velocity1, flow1, flowMusic1, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize1);
+                    CreateParticles(cache, ps, x1, y1, direction1, velocity1, flow1, flowMusic1, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize1);
                     break;
                 case 1:
-                    CreateParticles(ps, x2, y2, direction2, velocity2, flow2, flowMusic2, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize2);
+                    CreateParticles(cache, ps, x2, y2, direction2, velocity2, flow2, flowMusic2, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize2);
                     break;
                 case 2:
-                    CreateParticles(ps, x3, y3, direction3, velocity3, flow3, flowMusic3, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize3);
+                    CreateParticles(cache, ps, x3, y3, direction3, velocity3, flow3, flowMusic3, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize3);
                     break;
                 case 3:
-                    CreateParticles(ps, x4, y4, direction4, velocity4, flow4, flowMusic4, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize4);
+                    CreateParticles(cache, ps, x4, y4, direction4, velocity4, flow4, flowMusic4, lifetime, buffer.BufferWi, buffer.BufferHt, color, particleType, mixcolors, audioLevel, sourceSize4);
                     break;
                 }
                 j++;
@@ -586,6 +589,7 @@ void LiquidEffect::Render(RenderBuffer &buffer,
     if (cache == nullptr) {
         cache = new LiquidRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     b2World*& _world = cache->_world;
 
@@ -598,6 +602,8 @@ void LiquidEffect::Render(RenderBuffer &buffer,
     {
         buffer.needToInit = false;
 
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+
         if (_world != nullptr)
         {
             delete _world;
diff --git a/xLights/effects/LiquidEffect.h b/xLights/effects/LiquidEffect.h
index fafcfab55..1282aaab9 100644
--- a/xLights/effects/LiquidEffect.h
+++ b/xLights/effects/LiquidEffect.h
@@ -131,7 +131,7 @@ protected:
                 const std::string& particleType, int despeckle, float gravity, int gravityAngle);
     void CreateBarrier(b2World* world, float x, float y, float width, float height);
     void Draw(RenderBuffer& buffer, b2ParticleSystem* ps, const xlColor& color, bool mixColors, int despeckle);
-    void CreateParticles(b2ParticleSystem* ps, int x, int y, int direction, int velocity, int flow, bool flowMusic, int lifetime, int width, int height, const xlColor& c, const std::string& particleType, bool mixcolors, float audioLevel, int sourceSize);
+    void CreateParticles(EffectRenderStatePRNG* cache, b2ParticleSystem* ps, int x, int y, int direction, int velocity, int flow, bool flowMusic, int lifetime, int width, int height, const xlColor& c, const std::string& particleType, bool mixcolors, float audioLevel, int sourceSize);
     void CreateParticleSystem(b2World* world, int lifetime, int size);
     void Step(b2World* world, RenderBuffer& buffer, bool enabled[], int lifetime, const std::string& particleType, bool mixcolors,
               int x1, int y1, int direction1, int velocity1, int flow1, int sourceSize1, bool flowMusic1,
diff --git a/xLights/effects/MeteorsEffect.cpp b/xLights/effects/MeteorsEffect.cpp
index 14d20c7a7..543a38c29 100644
--- a/xLights/effects/MeteorsEffect.cpp
+++ b/xLights/effects/MeteorsEffect.cpp
@@ -115,7 +115,7 @@ public:
 typedef std::list<MeteorClass> MeteorList;
 typedef std::list<MeteorRadialClass> MeteorRadialList;
 
-class MeteorsRenderCache : public EffectRenderCache {
+class MeteorsRenderCache : public EffectRenderStatePRNG {
 public:
     MeteorsRenderCache() {};
     virtual ~MeteorsRenderCache() {};
@@ -131,6 +131,7 @@ static MeteorsRenderCache* GetCache(RenderBuffer &buffer, int id) {
     if (cache == nullptr) {
         cache = new MeteorsRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     return cache;
 }
@@ -194,6 +195,7 @@ void MeteorsEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
 
     if (buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         cache->meteors.clear();
         cache->meteorsRadial.clear();
         cache->effectState = mSpeed * buffer.frameTimeInMs / 50;
@@ -264,16 +266,16 @@ void MeteorsEffect::RenderMeteorsHorizontal(RenderBuffer &buffer, int ColorSchem
     // create new meteors
 
     for (int i = 0; i < buffer.BufferHt; i++) {
-        if (rand() % 200 < Count) {
+        if (cache->prngint(200) < Count) {
             m.x=buffer.BufferWi - 1;
             m.y=i;
 
             switch (ColorScheme) {
                 case 1:
-                    buffer.SetRangeColor(hsv0,hsv1,m.hsv);
+                    cache->RandomColorInRange(hsv0,hsv1,m.hsv);
                     break;
                 case 2:
-                    buffer.palette.GetHSV(rand()%colorcnt, m.hsv);
+                    buffer.palette.GetHSV(cache->prngint(colorcnt), m.hsv);
                     break;
             }
             cache->meteors.push_back(m);
@@ -285,10 +287,16 @@ void MeteorsEffect::RenderMeteorsHorizontal(RenderBuffer &buffer, int ColorSchem
     std::function<void(MeteorClass &, int)> f = [&buffer, MeteorsEffect, TailLength, mspeed, SwirlIntensity, ColorScheme] (MeteorClass &meteor, int n) {
         int x,y,dy;
         HSVValue hsv;
+
+        EffectRenderStatePRNG prng;
+        if (ColorScheme == 0) {
+            prng.seedConsistently(meteor.x, meteor.y, n * 100, buffer.BufferWi * 100 + buffer.BufferHt);
+        }
+
         for (int ph = 0; ph <= TailLength; ph++) {
             switch (ColorScheme) {
                 case 0:
-                    hsv.hue=double(rand() % 1000) / 1000.0;
+                    hsv.hue = prng.prnguniform();
                     hsv.saturation=1.0;
                     hsv.value=1.0;
                     break;
@@ -365,16 +373,16 @@ void MeteorsEffect::RenderMeteorsVertical(RenderBuffer &buffer, int ColorScheme,
     // create new meteors
 
     for (int i = 0; i < buffer.BufferWi; i++) {
-        if (rand() % 200 < Count) {
+        if (cache->prngint(200) < Count) {
             m.x=i;
             m.y=buffer.BufferHt - 1;
 
             switch (ColorScheme) {
                 case 1:
-                    buffer.SetRangeColor(hsv0,hsv1,m.hsv);
+                    cache->RandomColorInRange(hsv0,hsv1,m.hsv);
                     break;
                 case 2:
-                    buffer.palette.GetHSV(rand()%colorcnt, m.hsv);
+                    buffer.palette.GetHSV(cache->prngint(colorcnt), m.hsv);
                     break;
             }
             cache->meteors.push_back(m);
@@ -386,10 +394,16 @@ void MeteorsEffect::RenderMeteorsVertical(RenderBuffer &buffer, int ColorScheme,
     std::function<void(MeteorClass &, int)> f = [&buffer, MeteorsEffect, TailLength, mspeed, SwirlIntensity, ColorScheme] (MeteorClass &meteor, int n) {
         int x,y,dx;
         HSVValue hsv;
+
+        EffectRenderStatePRNG prng;
+        if (ColorScheme == 0) {
+            prng.seedConsistently(meteor.x, meteor.y, n * 100, buffer.BufferWi * 100 + buffer.BufferHt);
+        }
+
         for (int ph = 0; ph <= TailLength; ph++) {
             switch (ColorScheme) {
                 case 0:
-                    hsv.hue=double(rand() % 1000) / 1000.0;
+                    hsv.hue=prng.prnguniform();
                     hsv.saturation=1.0;
                     hsv.value=1.0;
                     break;
@@ -449,18 +463,18 @@ void MeteorsEffect::RenderIcicleDrip(RenderBuffer &buffer, int ColorScheme, int
 
     MeteorClass m;
     for (int i = 0; i < buffer.BufferWi; i++) {
-        if (rand() % 200 < Count) {
+        if (cache->prngint(200) < Count) {
             m.x=i;
             m.y=buffer.BufferHt - 1;
             //            m.h = TailLength;
-            m.h = (rand() % (2 * buffer.BufferHt))/3; //somewhat variable length -DJ
+            m.h = (cache->prngint(2 * buffer.BufferHt))/3; //somewhat variable length -DJ
 
             switch (ColorScheme) {
                 case 1:
-                    buffer.SetRangeColor(hsv0,hsv1,m.hsv);
+                    cache->RandomColorInRange(hsv0,hsv1,m.hsv);
                     break;
                 case 2:
-                    buffer.palette.GetHSV(rand()%colorcnt, m.hsv);
+                    buffer.palette.GetHSV(cache->prngint(colorcnt), m.hsv);
                     break;
             }
             cache->meteors.push_back(m);
@@ -557,13 +571,13 @@ void MeteorsEffect::RenderMeteorsImplode(RenderBuffer &buffer, int ColorScheme,
 
     m.cnt=1;
     for (int i = 0; i < MinDimension; i++) {
-        if (rand() % 200 < Count) {
+        if (cache->prngint(200) < Count) {
             if (buffer.BufferHt == 1) {
-                angle=double(rand() % 2) * M_PI;
+                angle=double(cache->prngint(2)) * M_PI;
             } else if (buffer.BufferWi == 1) {
-                angle=double(rand() % 2) * M_PI - (M_PI/2.0);
+                angle=double(cache->prngint(2)) * M_PI - (M_PI/2.0);
             } else {
-                angle=rand01()*2.0*M_PI;
+                angle = cache->prnguniform() * 2.0 * M_PI;
             }
             m.dx=buffer.cos(angle);
             m.dy=buffer.sin(angle);
@@ -574,10 +588,10 @@ void MeteorsEffect::RenderMeteorsImplode(RenderBuffer &buffer, int ColorScheme,
 
             switch (ColorScheme) {
                 case 1:
-                    buffer.SetRangeColor(hsv0,hsv1,m.hsv);
+                    cache->RandomColorInRange(hsv0,hsv1,m.hsv);
                     break;
                 case 2:
-                    buffer.palette.GetHSV(rand()%colorcnt, m.hsv);
+                    buffer.palette.GetHSV(cache->prngint(colorcnt), m.hsv);
                     break;
             }
             cache->meteorsRadial.push_back(m);
@@ -596,10 +610,15 @@ void MeteorsEffect::RenderMeteorsImplode(RenderBuffer &buffer, int ColorScheme,
             hdistance = std::max(0.1f, (float)sqrt((x - (float)centerX) * (x - (float)centerX) + (y - (float)centerY) * (y - (float)centerY)) / (float)maxdiag);
         }
 
+        EffectRenderStatePRNG prng;
+        if (ColorScheme == 0) {
+            prng.seedConsistently(meteor.x, meteor.y, n * 100, buffer.BufferWi * 100 + buffer.BufferHt);
+        }
+
         for (int ph = 0; ph <= TailLength; ph++) {
             switch (ColorScheme) {
                 case 0:
-                    hsv.hue=double(rand() % 1000) / 1000.0;
+                    hsv.hue = prng.prnguniform();
                     hsv.saturation=1.0;
                     hsv.value=1.0;
                     break;
@@ -694,23 +713,23 @@ void MeteorsEffect::RenderMeteorsExplode(RenderBuffer &buffer, int ColorScheme,
     m.y=buffer.BufferHt/2+trueyoffset;
     m.cnt=1;
     for (int i = 0; i < MinDimension; i++) {
-        if (rand() % 200 < Count) {
+        if (cache->prngint(200) < Count) {
             if (buffer.BufferHt == 1) {
-                angle=double(rand() % 2) * M_PI;
+                angle=double(cache->prngint(2)) * M_PI;
             } else if (buffer.BufferWi == 1) {
-                angle=double(rand() % 2) * M_PI - (M_PI/2.0);
+                angle=double(cache->prngint(2)) * M_PI - (M_PI/2.0);
             } else {
-                angle=rand01()*2.0*M_PI;
+                angle = cache->prnguniform() * 2.0 * M_PI;
             }
             m.dx=buffer.cos(angle);
             m.dy=buffer.sin(angle);
 
             switch (ColorScheme) {
                 case 1:
-                    buffer.SetRangeColor(hsv0,hsv1,m.hsv);
+                    cache->RandomColorInRange(hsv0,hsv1,m.hsv);
                     break;
                 case 2:
-                    buffer.palette.GetHSV(rand()%colorcnt, m.hsv);
+                    buffer.palette.GetHSV(cache->prngint(colorcnt), m.hsv);
                     break;
             }
             cache->meteorsRadial.push_back(m);
@@ -730,11 +749,16 @@ void MeteorsEffect::RenderMeteorsExplode(RenderBuffer &buffer, int ColorScheme,
             hdistance = std::max(0.1f, (float)sqrt((x - (float)centerX) * (x - (float)centerX) + (y - (float)centerY) * (y - (float)centerY)) / (float)maxdiag);
         }
 
+        EffectRenderStatePRNG prng;
+        if (ColorScheme == 0) {
+            prng.seedConsistently(meteor.x, meteor.y, n * 100, buffer.BufferWi * 100 + buffer.BufferHt);
+        }
+
         for(int ph = 0; ph <= TailLength; ph++) {
             //if (ph >= it->cnt) continue;
             switch (ColorScheme) {
                 case 0:
-                    hsv.hue=double(rand() % 1000) / 1000.0;
+                    hsv.hue = prng.prnguniform();
                     hsv.saturation=1.0;
                     hsv.value=1.0;
                     break;
diff --git a/xLights/effects/PicturesEffect.cpp b/xLights/effects/PicturesEffect.cpp
index de22d89d6..ecdd83c3a 100644
--- a/xLights/effects/PicturesEffect.cpp
+++ b/xLights/effects/PicturesEffect.cpp
@@ -942,11 +942,16 @@ void PicturesEffect::Render(RenderBuffer& buffer,
 
     // add shimmer effect which just randomly turns off pixels
     if (shimmer) {
+        EffectRenderStatePRNG prng;
+        prng.seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), PicturesEffectId);
+        prng.prngnext();
+        prng.prngnext();
+
         c = xlBLACK;
         xlColor color;
         for (int x = 0; x < BufferWi; x++) {
             for (int y = 0; y < BufferHt; y++) {
-                if (rand01() > 0.5) {
+                if (prng.prnguniform() > 0.5) {
                     buffer.GetPixel(x, y, color);
                     if (color != xlBLACK) {
                         buffer.ProcessPixel(x, y, c, false);
diff --git a/xLights/effects/RenderableEffect.h b/xLights/effects/RenderableEffect.h
index 0c8b1c849..e6be28692 100644
--- a/xLights/effects/RenderableEffect.h
+++ b/xLights/effects/RenderableEffect.h
@@ -31,6 +31,7 @@ class wxSpinCtrl;
 class xlEffectPanel;
 class EffectManager;
 class EffectLayer;
+class EffectRenderStatePRNG;
 
 class RenderableEffect
 {
diff --git a/xLights/effects/ShaderEffect.cpp b/xLights/effects/ShaderEffect.cpp
index 770a10b44..df984d031 100644
--- a/xLights/effects/ShaderEffect.cpp
+++ b/xLights/effects/ShaderEffect.cpp
@@ -1150,8 +1150,15 @@ void ShaderEffect::Render(Effect* eff, const SettingsMap& SettingsMap, RenderBuf
     si->SetUniform1f("TIMEDELTA", (GLfloat)(buffer.frameTimeInMs /1000.f));
 
     if (si->HasUniform("DATE")) {
-        wxDateTime dt = wxDateTime::Now();
-        si->SetUniform4f("DATE", dt.GetYear(), dt.GetMonth() + 1, dt.GetDay(), dt.GetHour() * 3600 + dt.GetMinute() * 60 + dt.GetSecond());
+        if (true) { // TODO: When is this to happen?
+            // TODO: Get the start time of the sequence, plus the start time of the effect, and put properly
+            int year = 2022, month = 12, day = 3, hour = 5, min = 6, sec = 7, ms = 102;
+            ms += int(_timeMS);
+            si->SetUniform4f("DATE", year, month, day, hour * 3600 + min * 60 + sec + (float(ms) / 1000.0));
+        } else {
+            wxDateTime dt = wxDateTime::Now(); // TODO: This is totally goofy / depends on render speed.  Get the render time at the start
+            si->SetUniform4f("DATE", dt.GetYear(), dt.GetMonth() + 1, dt.GetDay(), dt.GetHour() * 3600 + dt.GetMinute() * 60 + dt.GetSecond() + (dt.GetMillisecond() / 1000.0));
+        }
     }
     si->SetUniformInt("PASSINDEX", 0);
     si->SetUniformInt("FRAMEINDEX", _timeMS / buffer.frameTimeInMs);
diff --git a/xLights/effects/ShapeEffect.cpp b/xLights/effects/ShapeEffect.cpp
index 9d4823540..cbdea589f 100644
--- a/xLights/effects/ShapeEffect.cpp
+++ b/xLights/effects/ShapeEffect.cpp
@@ -261,7 +261,7 @@ bool compare_shapes(const ShapeData* first, const ShapeData* second)
     return first->_oset > second->_oset;
 }
 
-class ShapeRenderCache : public EffectRenderCache {
+class ShapeRenderCache : public EffectRenderStatePRNG {
 
 public:
     ShapeRenderCache() { _lastColorIdx = -1; _sinceLastTriggered = 0; }
@@ -292,12 +292,12 @@ public:
         }
     }
 
-    void AddShape(wxPoint centre, float size, xlColor color, int oset, int shape, int angle, int speed, bool randomMovement, bool holdColour, int colourIndex)
+    void AddShape(EffectRenderStatePRNG *cache, wxPoint centre, float size, xlColor color, int oset, int shape, int angle, int speed, bool randomMovement, bool holdColour, int colourIndex)
     {
         if (randomMovement)
         {
-            speed = rand01() * (SHAPE_VELOCITY_MAX - SHAPE_VELOCITY_MIN) - SHAPE_VELOCITY_MIN;
-            angle = rand01() * (SHAPE_DIRECTION_MAX - SHAPE_DIRECTION_MIN) - SHAPE_VELOCITY_MIN;
+            speed = cache->prnguniform() * (SHAPE_VELOCITY_MAX - SHAPE_VELOCITY_MIN) - SHAPE_VELOCITY_MIN;
+            angle = cache->prnguniform() * (SHAPE_DIRECTION_MAX - SHAPE_DIRECTION_MIN) - SHAPE_VELOCITY_MIN;
         }
         _shapes.push_back(new ShapeData(centre, size, oset, color, shape, angle, speed, holdColour, colourIndex));
     }
@@ -332,7 +332,7 @@ public:
     }
 };
 
-int ShapeEffect::DecodeShape(const std::string& shape)
+int ShapeEffect::DecodeShape(EffectRenderStatePRNG *prng, const std::string& shape)
 {
     if (shape == "Circle") {
         return RENDER_SHAPE_CIRCLE;
@@ -370,7 +370,7 @@ int ShapeEffect::DecodeShape(const std::string& shape)
         return RENDER_SHAPE_SVG;
     }
 
-    return rand01() * 13; // exclude emoji
+    return prng->prngint(14); // exclude emoji
 }
 
 static int mapSkinTone(const std::string &v) {
@@ -414,8 +414,6 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
 
     int rotation = GetValueCurveInt("Shape_Rotation", 0, SettingsMap, oset, SHAPE_ROTATION_MIN, SHAPE_ROTATION_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
 
-    int Object_To_Draw = DecodeShape(Object_To_DrawStr);
-
     float f = 0.0;
     bool useMusic = SettingsMap.GetBool("CHECKBOX_Shape_UseMusic", false);
     float sensitivity = (float)SettingsMap.GetInt("SLIDER_Shape_Sensitivity", 50) / 100.0;
@@ -432,12 +430,15 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
         }
     }
 
-    ShapeRenderCache *cache = (ShapeRenderCache*)buffer.infoCache[id];
+    ShapeRenderCache* cache = (ShapeRenderCache*)buffer.infoCache[id];
     if (cache == nullptr) {
         cache = new ShapeRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
 
+    int Object_To_Draw = DecodeShape(cache, Object_To_DrawStr);
+
     std::list<ShapeData*>& _shapes = cache->_shapes;
     int& _lastColorIdx = cache->_lastColorIdx;
     int& _sinceLastTriggered = cache->_sinceLastTriggered;
@@ -449,7 +450,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
 
     if (buffer.needToInit) {
         buffer.needToInit = false;
-
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         _sinceLastTriggered = 0;
 
         if (Object_To_Draw == RENDER_SHAPE_EMOJI) {
@@ -465,7 +466,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
             for (int i = _shapes.size(); i < count; ++i) {
                 wxPoint pt;
                 if (randomLocation) {
-                    pt = wxPoint(rand01() * buffer.BufferWi, rand01() * buffer.BufferHt);
+                    pt = wxPoint(cache->prnguniform() * buffer.BufferWi, cache->prnguniform() * buffer.BufferHt);
                 } else {
                     pt = wxPoint(xc, yc);
                 }
@@ -479,10 +480,10 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                 int os = 0;
                 if (startRandomly)
                 {
-                    os = rand01() * lifetimeFrames;
+                    os = cache->prnguniform() * lifetimeFrames;
                 }
 
-                cache->AddShape(pt, startSize + os * growthPerFrame, buffer.palette.GetColor(_lastColorIdx), os, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
+                cache->AddShape(cache, pt, startSize + os * growthPerFrame, buffer.palette.GetColor(_lastColorIdx), os, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
             }
             cache->SortShapes();
         }
@@ -524,7 +525,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                         wxPoint pt;
                         if (randomLocation)
                         {
-                            pt = wxPoint(rand01() * buffer.BufferWi, rand01() * buffer.BufferHt);
+                            pt = wxPoint(cache->prnguniform() * buffer.BufferWi, cache->prnguniform() * buffer.BufferHt);
                         }
                         else
                         {
@@ -538,7 +539,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                             _lastColorIdx = 0;
                         }
 
-                        cache->AddShape(pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
+                        cache->AddShape(cache, pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
                         break;
                     }
                 }
@@ -556,7 +557,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                 wxPoint pt;
                 if (randomLocation)
                 {
-                    pt = wxPoint(rand01() * buffer.BufferWi, rand01() * buffer.BufferHt);
+                    pt = wxPoint(cache->prnguniform() * buffer.BufferWi, cache->prnguniform() * buffer.BufferHt);
                 }
                 else
                 {
@@ -570,7 +571,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                     _lastColorIdx = 0;
                 }
 
-                cache->AddShape(pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
+                cache->AddShape(cache, pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
             }
 
             // if music is over the trigger level for REPEATTRIGGER frames then we will trigger another firework
@@ -593,7 +594,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
             wxPoint pt;
             if (randomLocation)
             {
-                pt = wxPoint(rand01() * buffer.BufferWi, rand01() * buffer.BufferHt);
+                pt = wxPoint(cache->prnguniform() * buffer.BufferWi, cache->prnguniform() * buffer.BufferHt);
             }
             else
             {
@@ -607,7 +608,7 @@ void ShapeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderB
                 _lastColorIdx = 0;
             }
 
-            cache->AddShape(pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
+            cache->AddShape(cache, pt, startSize, buffer.palette.GetColor(_lastColorIdx), 0, Object_To_Draw, direction, velocity, randomMovement, holdColour, _lastColorIdx);
         }
     }
 
diff --git a/xLights/effects/ShapeEffect.h b/xLights/effects/ShapeEffect.h
index 213d5cfb7..844909893 100644
--- a/xLights/effects/ShapeEffect.h
+++ b/xLights/effects/ShapeEffect.h
@@ -126,7 +126,7 @@ protected:
     virtual xlEffectPanel* CreatePanel(wxWindow* parent) override;
 
 private:
-    static int DecodeShape(const std::string& shape);
+    static int DecodeShape(EffectRenderStatePRNG* prng, const std::string& shape);
     void SetPanelTimingTracks() const;
     void Drawcircle(RenderBuffer& buffer, int xc, int yc, double radius, xlColor color, int thickness) const;
     void Drawheart(RenderBuffer& buffer, int xc, int yc, double radius, xlColor color, int thickness, double rotation) const;
diff --git a/xLights/effects/ShimmerEffect.cpp b/xLights/effects/ShimmerEffect.cpp
index b912b6324..e6d9e0255 100644
--- a/xLights/effects/ShimmerEffect.cpp
+++ b/xLights/effects/ShimmerEffect.cpp
@@ -123,10 +123,13 @@ void ShimmerEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
 
     xlColor color;
     buffer.palette.GetColor(ColorIdx, color);
+    EffectRenderStatePRNG prng;
+    prng.seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+
     for (int y = 0; y < buffer.BufferHt; y++) {
         for (int x = 0; x < buffer.BufferWi; x++) {
             if (Use_All_Colors) {                         // Should we randomly assign colors from palette or cycle thru sequentially?
-                ColorIdx = rand() % colorcnt;             // Select random numbers from 0 up to number of colors the user has checked. 0-5 if 6 boxes checked
+                ColorIdx = prng.prngint(colorcnt);             // Select random numbers from 0 up to number of colors the user has checked. 0-5 if 6 boxes checked
                 buffer.palette.GetColor(ColorIdx, color); // Now go and get the hsv value for this ColorIdx
             } else {
                 buffer.palette.GetSpatialColor(ColorIdx, (float)x / (float)buffer.BufferWi, (float)y / (float)buffer.BufferHt, color);
diff --git a/xLights/effects/SnowflakesEffect.cpp b/xLights/effects/SnowflakesEffect.cpp
index b6edb760c..775b231f0 100644
--- a/xLights/effects/SnowflakesEffect.cpp
+++ b/xLights/effects/SnowflakesEffect.cpp
@@ -133,7 +133,7 @@ static void set_pixel_if_not_color(RenderBuffer &buffer, int x, int y, xlColor t
     }
 }
 
-class SnowflakesRenderCache : public EffectRenderCache {
+class SnowflakesRenderCache : public EffectRenderStatePRNG {
 public:
     SnowflakesRenderCache() : LastSnowflakeCount(0), LastSnowflakeType(0), LastFalling(""), effectState(0) {};
     virtual ~SnowflakesRenderCache() {};
@@ -180,6 +180,7 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
     if (cache == nullptr) {
         cache = new SnowflakesRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
 
     int &LastSnowflakeCount = cache->LastSnowflakeCount;
@@ -194,7 +195,11 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
     if (buffer.needToInit ||
         (Count != LastSnowflakeCount && falling == "Driving") ||
         SnowflakeType != LastSnowflakeType ||
-        falling != LastFalling) {
+        falling != LastFalling)
+    {
+        if (buffer.needToInit) {
+            cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+        }
 
         // initialize
         buffer.needToInit = false;
@@ -219,8 +224,8 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
             // find unused space
             for (check = 0; check < 20; check++)
             {
-                x = rand() % buffer.BufferWi;
-                y = y0 + (rand() % delta_y);
+                x = cache->prngint(buffer.BufferWi);
+                y = y0 + (cache->prngint(delta_y));
                 if (buffer.GetTempPixel(x, y) == xlBLACK) {
                     effectState++;
                     break;
@@ -228,7 +233,7 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
             }
 
             // draw flake, SnowflakeType=0 is random type
-            switch (SnowflakeType == 0 ? rand() % 9 : SnowflakeType - 1)
+            switch (SnowflakeType == 0 ? cache->prngint(9) : SnowflakeType - 1)
             {
             case 0:
                 // single node
@@ -269,7 +274,7 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
                 else
                 {
                     buffer.SetTempPixel(x, y, c1);
-                    if (rand() % 100 > 50)      // % 2 was not so random
+                    if (cache->prngint(100) > 50) // Slight preference for else branch
                     {
                         buffer.SetTempPixel(x - 1, y, c2);
                         buffer.SetTempPixel(x + 1, y, c2);
@@ -442,7 +447,7 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
                         if (moves > 0 || (falling == "Falling" && y == 0))
                         {
                             int x0;
-                            switch (rand() % 9)
+                            switch (cache->prngint(9))
                             {
                             case 0:
                                 if (moves & 1) {
@@ -481,9 +486,9 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
                                     x0 = x - 1;
                                 }
                                 else {
-                                    switch (rand() % 2)
+                                    switch (cache->prngbool())
                                     {
-                                    case 0:
+                                    case true:
                                         x0 = x + 1;
                                         break;
                                     default:
@@ -554,10 +559,10 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
         int placedFullCount = 0;
         while (effectState < Count && check < 20) {
             // find unused space
-            int x = rand() % buffer.BufferWi;
+            int x = cache->prngint(buffer.BufferWi);
             if (buffer.GetTempPixel(x, buffer.BufferHt - 1) == xlBLACK) {
                 effectState++;
-                buffer.SetTempPixel(x, buffer.BufferHt - 1, color1, SnowflakeType == 0 ? rand() % 9 : SnowflakeType - 1);
+                buffer.SetTempPixel(x, buffer.BufferHt - 1, color1, SnowflakeType == 0 ? cache->prngint(9) : SnowflakeType - 1);
 
                 int nextmoves = possible_downward_moves(buffer, x, buffer.BufferHt - 1);
                 if (nextmoves == 0) {
@@ -611,7 +616,7 @@ void SnowflakesEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Re
                             set_pixel_if_not_color(buffer, x + 1, y, color2, color1, wrapx, false);
                         }
                         else {
-                            if (rand() % 100 > 50)      // % 2 was not so random
+                            if (cache->prngint(100) > 50)      // ever so slight preference for else branch
                             {
                                 set_pixel_if_not_color(buffer, x - 1, y, color2, color1, wrapx, false);
                                 set_pixel_if_not_color(buffer, x + 1, y, color2, color1, wrapx, false);
diff --git a/xLights/effects/SnowstormEffect.cpp b/xLights/effects/SnowstormEffect.cpp
index de4f32a3d..7b01d69da 100644
--- a/xLights/effects/SnowstormEffect.cpp
+++ b/xLights/effects/SnowstormEffect.cpp
@@ -85,13 +85,23 @@ static wxPoint SnowstormVector(int idx)
     return xy;
 }
 
-static void SnowstormAdvance(RenderBuffer& buffer, SnowstormClass& ssItem)
+class SnowstormRenderCache : public EffectRenderStatePRNG
+{
+public:
+    SnowstormRenderCache(){};
+    virtual ~SnowstormRenderCache(){};
+
+    int LastSnowstormCount;
+    std::list<SnowstormClass> SnowstormItems;
+};
+
+static void SnowstormAdvance(RenderBuffer& buffer, SnowstormClass& ssItem, SnowstormRenderCache *cache)
 {
     const int cnt = 8;  // # of integers in each set in arr[]
     const int arr[] = { 30,20,10,5,0,5,10,20,20,15,10,10,10,10,10,15 }; // 2 sets of 8 numbers, each of which add up to 100
     wxPoint adv = SnowstormVector(7);
     int i0 = ssItem.idx % 7 <= 4 ? 0 : cnt;
-    int r = rand() % 100;
+    int r = cache->prngint(100);
     for (int i = 0, val = 0; i < cnt; i++)
     {
         val += arr[i0 + i];
@@ -115,15 +125,6 @@ static void SnowstormAdvance(RenderBuffer& buffer, SnowstormClass& ssItem)
     ssItem.points.push_back(xy);
 }
 
-class SnowstormRenderCache : public EffectRenderCache {
-public:
-    SnowstormRenderCache() {};
-    virtual ~SnowstormRenderCache() {};
-    
-    int LastSnowstormCount;
-    std::list<SnowstormClass> SnowstormItems;
-};
-
 void SnowstormEffect::SetDefaultParameters()
 {
     SnowstormPanel *sp = (SnowstormPanel*)panel;
@@ -159,6 +160,8 @@ void SnowstormEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Ren
 
     if (buffer.needToInit || Count != cache->LastSnowstormCount) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+
         // create snowstorm elements
         cache->LastSnowstormCount = Count;
         SnowstormItems.clear();
@@ -168,14 +171,14 @@ void SnowstormEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Ren
             ssItem.idx = i;
             ssItem.ssDecay = 0;
             ssItem.points.clear();
-            buffer.SetRangeColor(hsv0, hsv1, ssItem.hsv);
+            cache->RandomColorInRange(hsv0, hsv1, ssItem.hsv);
 
             // start in a random state
-            int r = rand() % (2 * TailLength);
+            int r = cache->prngint(2 * TailLength);
             if (r > 0) {
                 wxPoint xy;
-                xy.x = rand() % buffer.BufferWi;
-                xy.y = rand() % buffer.BufferHt;
+                xy.x = cache->prngint(buffer.BufferWi);
+                xy.y = cache->prngint(buffer.BufferHt);
                 ssItem.points.push_back(xy);
             }
             if (r >= TailLength) {
@@ -183,7 +186,7 @@ void SnowstormEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Ren
                 r = TailLength;
             }
             for (int j = 1; j < r; j++) {
-                SnowstormAdvance(buffer, ssItem);
+                SnowstormAdvance(buffer, ssItem, cache);
             }
             SnowstormItems.push_back(ssItem);
         }
@@ -193,7 +196,7 @@ void SnowstormEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Ren
         // This updates the colours where using colour curves
         for (auto& it : SnowstormItems) {
             int val = it.hsv.value;
-            buffer.SetRangeColor(hsv0, hsv1, it.hsv);
+            cache->RandomColorInRange(hsv0, hsv1, it.hsv);
             it.hsv.value = val;
         }
     }
@@ -206,19 +209,19 @@ void SnowstormEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Ren
                 it.points.clear();  // start over
                 it.ssDecay = 0;
             }
-            else if (rand() % 20 < sSpeed) {
+            else if (cache->prngint(20) < sSpeed) {
                 it.ssDecay++;
             }
         }
 
         if (it.points.empty()) {
             wxPoint xy;
-            xy.x = rand() % buffer.BufferWi;
-            xy.y = rand() % buffer.BufferHt;
+            xy.x = cache->prngint(buffer.BufferWi);
+            xy.y = cache->prngint(buffer.BufferHt);
             it.points.push_back(xy);
         }
-        else if (rand() % 20 < sSpeed) {
-            SnowstormAdvance(buffer, it);
+        else if (cache->prngint(20) < sSpeed) {
+            SnowstormAdvance(buffer, it, cache);
         }
 
         int sz = it.points.size();
diff --git a/xLights/effects/SpiralsEffect.cpp b/xLights/effects/SpiralsEffect.cpp
index e0fb9a55f..fd3c6ade8 100644
--- a/xLights/effects/SpiralsEffect.cpp
+++ b/xLights/effects/SpiralsEffect.cpp
@@ -146,9 +146,12 @@ void SpiralsEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
                 }
             }
         };
-        
-        if ((!isSpacial && !Blend) && SpiralThickness > 2) {
+
+        if ((!isSpacial && !Blend) && SpiralThickness > 999999999) {
+        //if ((!isSpacial && !Blend) && SpiralThickness > 2) {
             // if we aren't blending or dealing with spacial, we can use parallel
+            // This goes in a vertical direction; potential for splash damage.  Not clear what it has to do with spatial either.
+            //   Or the performance benefit; the height would determine that I suppose.  Should be possible to rasterize
             parallel_for(0, SpiralThickness, [&spiralF](int i) { spiralF(i); }, 1);
         } else {
             for (int i = 0; i < SpiralThickness; i++) {
diff --git a/xLights/effects/SpirographEffect.cpp b/xLights/effects/SpirographEffect.cpp
index 629e688c3..b7ef17295 100644
--- a/xLights/effects/SpirographEffect.cpp
+++ b/xLights/effects/SpirographEffect.cpp
@@ -71,7 +71,7 @@ void SpirographEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Re
     int width = GetValueCurveInt("Spirograph_Width", 1, SettingsMap, oset, SPIROGRAPH_WIDTH_MIN, SPIROGRAPH_WIDTH_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
 
     int d_mod;
-    HSVValue hsv, hsv0, hsv1;
+    HSVValue hsv, hsv0;
     size_t colorcnt = buffer.GetColorCount();
 
     int state = (buffer.curPeriod - buffer.curEffStartPer) * sspeed * buffer.frameTimeInMs / 50;
@@ -90,8 +90,6 @@ void SpirographEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Re
     if (r > R) r = R;
     float d = xc * (int_d / 100.0);
 
-    //  palette.GetHSV(1, hsv1);
-    //
     //    A hypotrochoid is a roulette traced by a point attached to a circle of radius r rolling around the inside of a fixed circle of radius R, where the point is a distance d from the center of the interior circle.
     //The parametric equations for a hypotrochoid are:[citation needed]
     //
@@ -126,8 +124,6 @@ void SpirographEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Re
         buffer.palette.GetHSV(ColorIdx, hsv); // Now go and get the hsv value for this ColorIdx
 
         buffer.palette.GetHSV(0, hsv0);
-        ColorIdx = (colorcnt > 0) ? (state + rand()) % colorcnt : 0; // Select random numbers from 0 up to number of colors the user has checked. 0-5 if 6 boxes checked
-        buffer.palette.GetHSV(ColorIdx, hsv1); // Now go and get the hsv value for this ColorIdx
 
         // work out the normal to the point being drawn
         float tt = ((R - r) / r) * t;
diff --git a/xLights/effects/StrobeEffect.cpp b/xLights/effects/StrobeEffect.cpp
index bc8a9d81b..4c6f11b81 100644
--- a/xLights/effects/StrobeEffect.cpp
+++ b/xLights/effects/StrobeEffect.cpp
@@ -68,7 +68,7 @@ public:
     }
 };
 
-class StrobeRenderCache : public EffectRenderCache {
+class StrobeRenderCache : public EffectRenderStatePRNG {
 public:
     StrobeRenderCache() {};
     virtual ~StrobeRenderCache() {};
@@ -110,6 +110,7 @@ void StrobeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Render
     if (cache == nullptr) {
         cache = new StrobeRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     std::list<StrobeClass> &strobe = cache->strobe;
 
@@ -123,16 +124,17 @@ void StrobeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Render
 
     if (buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         strobe.clear();
 
         // prepopulate first frame
         for (int i = 0; i < Number_Strobes * StrobeDuration; i++) {
             xlColor color;
-            ColorIdx = rand() % colorcnt;
+            ColorIdx = cache->prngint(colorcnt);
             buffer.palette.GetHSV(ColorIdx, hsv); // take first checked color as color of flash
             buffer.palette.GetColor(ColorIdx, color); // take first checked color as color of flash
-            strobe.push_back(StrobeClass(rand() % buffer.BufferWi,
-                rand() % buffer.BufferHt, i % StrobeDuration, hsv, color));
+            strobe.push_back(StrobeClass(cache->prngint(buffer.BufferWi),
+                cache->prngint(buffer.BufferHt), i % StrobeDuration, hsv, color));
         }
     }
 
@@ -140,11 +142,11 @@ void StrobeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Render
     while (strobe.size() < Number_Strobes * StrobeDuration) {
         HSVValue hsv;
         xlColor color;
-        ColorIdx = rand() % colorcnt;
+        ColorIdx = cache->prngint(colorcnt);
         buffer.palette.GetHSV(ColorIdx, hsv); // take first checked color as color of flash
         buffer.palette.GetColor(ColorIdx, color); // take first checked color as color of flash
-        strobe.push_back(StrobeClass(rand() % buffer.BufferWi,
-            rand() % buffer.BufferHt, StrobeDuration, hsv, color));
+        strobe.push_back(StrobeClass(cache->prngint(buffer.BufferWi),
+            cache->prngint(buffer.BufferHt), StrobeDuration, hsv, color));
     }
 
     // render strobe, we go through all storbes and decide if they should be turned on
@@ -174,8 +176,7 @@ void StrobeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Render
         }
 
         if (Strobe_Type == 2) {
-            int r = rand() % 2;
-            if (r == 0) {
+            if (!cache->prngbool()) {
                 buffer.SetPixel(x, y - 1, color);
                 buffer.SetPixel(x, y + 1, color);
             } else {
@@ -190,8 +191,7 @@ void StrobeEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Render
             buffer.SetPixel(x + 1, y, color);
         }
         if (Strobe_Type == 4) {
-            int r = rand() % 2;
-            if (r == 0) {
+            if (!cache->prngbool()) {
                 buffer.SetPixel(x, y - 1, color);
                 buffer.SetPixel(x, y + 1, color);
                 buffer.SetPixel(x - 1, y, color);
diff --git a/xLights/effects/TendrilEffect.cpp b/xLights/effects/TendrilEffect.cpp
index 35d2e5a45..394700be4 100644
--- a/xLights/effects/TendrilEffect.cpp
+++ b/xLights/effects/TendrilEffect.cpp
@@ -30,6 +30,52 @@
 
 #define wrdebug(...)
 
+class TendrilNode
+{
+public:
+    float x;
+    float y;
+    float vx;
+    float vy;
+
+    TendrilNode(float x_, float y_);
+    wxPoint* Point();
+};
+
+class ATendril
+{
+    float _friction;
+    size_t _size;
+    float _dampening;
+    float _tension;
+    float _spring;
+    size_t _thickness;
+    int _lastWidth = -1;
+    int _lastHeight = -1;
+
+    std::list<TendrilNode*> _nodes;
+
+public:
+    ~ATendril();
+    ATendril(EffectRenderStatePRNG *prng, float friction, int size, float dampening, float tension, float spring, const wxPoint& start);
+    void Update(wxPoint* target, int tunemovement, int width, int height);
+    void Draw(PathDrawingContext* gc, xlColor colour, int thickness);
+    wxPoint* LastLocation();
+};
+
+class Tendril
+{
+    std::list<ATendril*> _tendrils;
+
+public:
+    ~Tendril();
+    Tendril(EffectRenderStatePRNG *cache, float friction, int trails, int size, float dampening, float tension, float springbase, float springincr, const wxPoint& start);
+    void UpdateRandomMove(EffectRenderStatePRNG *prng, int tunemovement, int width, int height);
+    void Update(wxPoint* target, int tunemovement, size_t width, size_t height);
+    void Update(int x, int y, int tunemovement, size_t width, size_t height);
+    void Draw(PathDrawingContext* gc, xlColor colour, int thickness);
+};
+
 bool TendrilEffect::needToAdjustSettings(const std::string &version)
 {
 	return IsVersionOlder("2016.8", version);
@@ -104,7 +150,7 @@ ATendril::~ATendril()
     }
 }
 
-ATendril::ATendril(float friction, int size, float dampening, float tension, float spring, const wxPoint& start)
+ATendril::ATendril(EffectRenderStatePRNG *cache, float friction, int size, float dampening, float tension, float spring, const wxPoint& start)
 {
     _size = 60;
     if (size > 0) {
@@ -124,9 +170,9 @@ ATendril::ATendril(float friction, int size, float dampening, float tension, flo
     }
     _friction = 0.5f;
     if (friction >= 0) {
-        _friction = friction + ((float)rand()) / (float)RAND_MAX * 0.01f - 0.005f;
+        _friction = friction + cache->prnguniform() * 0.01f - 0.005f;
     } else {
-        _friction = _friction + ((float)rand()) / (float)RAND_MAX * 0.01f - 0.005f;
+        _friction = _friction + cache->prnguniform() * 0.01f - 0.005f;
     }
 
     _nodes.clear();
@@ -256,7 +302,7 @@ Tendril::~Tendril()
     }
 }
 
-Tendril::Tendril(float friction, int trails, int size, float dampening, float tension, float springbase, float springincr, const wxPoint& start)
+Tendril::Tendril(EffectRenderStatePRNG *cache, float friction, int trails, int size, float dampening, float tension, float springbase, float springincr, const wxPoint& start)
 {
     float sb = 0.45f;
     if (springbase >= 0) {
@@ -274,14 +320,14 @@ Tendril::Tendril(float friction, int trails, int size, float dampening, float te
     _tendrils.clear();
     for (int i = 0; i < t; i++) {
         float aspring = sb + si * ((float)i / (float)t);
-        ATendril* at = new ATendril(friction, size, dampening, tension, aspring, start);
+        ATendril* at = new ATendril(cache, friction, size, dampening, tension, aspring, start);
         if (at != nullptr) {
             _tendrils.push_back(at);
         }
     }
 }
 
-void Tendril::UpdateRandomMove(int tunemovement, int width, int height)
+void Tendril::UpdateRandomMove(EffectRenderStatePRNG *cache, int tunemovement, int width, int height)
 {
     if (tunemovement < 1) {
         tunemovement = 1;
@@ -322,11 +368,11 @@ void Tendril::UpdateRandomMove(int tunemovement, int width, int height)
             int ymove = -1 * realminmovey + realmaxmovey;
             int x = 0;
             if (xmove > 0) {
-                x = (rand() % xmove) + realminmovex;
+                x = (cache->prngnext() % xmove) + realminmovex;
             }
             int y = 0;
             if (ymove > 0) {
-                y = (rand() % ymove) + realminmovey;
+                y = (cache->prngnext() % ymove) + realminmovey;
             }
 
             current->x = current->x + x;
@@ -440,7 +486,7 @@ void TendrilEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
            GetValueCurveInt("Tendril_ManualY", 0, SettingsMap, oset, TENDRIL_MANUALY_MIN, TENDRIL_MANUALY_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS()));
 }
 
-class TendrilRenderCache : public EffectRenderCache
+class TendrilRenderCache : public EffectRenderStatePRNG
 {
 public:
     TendrilRenderCache()
@@ -519,6 +565,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
     if (cache == nullptr) {
         cache = new TendrilRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
 
     int& _mv1 = cache->_mv1;
@@ -536,6 +583,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
 
     if (_tendril == nullptr || buffer.needToInit) {
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         wxPoint startmiddle(buffer.BufferWi / 2 + truexoffset / 2, buffer.BufferHt / 2 + trueyoffset / 2);
         wxPoint startmiddletop(buffer.BufferWi / 2 + truexoffset / 2, buffer.BufferHt + trueyoffset);
         wxPoint startmiddlebottom(buffer.BufferWi / 2 + truexoffset / 2, 0 + trueyoffset);
@@ -551,7 +599,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
         switch (nMovement) {
         case 1:
             // random
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddle);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddle);
             break;
         case 2:
             // corners
@@ -562,7 +610,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
             if (_mv4 == 0) {
                 _mv4 = 1;
             }
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startbottomleft);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startbottomleft);
             break;
         case 3:
             // circles
@@ -572,7 +620,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
             if (_mv3 == 0) {
                 _mv3 = 1;
             }
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddle);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddle);
             break;
         case 4:
             // horizontal zig zag
@@ -582,14 +630,14 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
                 _mv2 = 1;
             }
             _mv3 = 1; // direction
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddlebottom);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddlebottom);
             break;
         case 5:
             // vertical zig zag
             _mv1 = 0 + truexoffset; // current x
             _mv2 = (double)tunemovement * 1.5;
             _mv3 = 1; // direction
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddleleft);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddleleft);
             break;
         case 6:
             // line movement based on music
@@ -598,7 +646,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
             if (_mv3 < 1) {
                 _mv3 = 1;
             }
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startbottomleft);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startbottomleft);
             break;
         case 7:
             // circle movement based on music
@@ -608,7 +656,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
             if (_mv3 < 1) {
                 _mv3 = 1;
             }
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddle);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddle);
             break;
         case 9:
             // horizontal zig zag return
@@ -618,17 +666,17 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
                 _mv2 = 1;
             }
             _mv3 = 1; // direction
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddlebottom);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddlebottom);
             break;
         case 8:
             // vertical zig zag return
             _mv1 = 0; // current x
             _mv2 = (double)tunemovement * 1.5;
             _mv3 = 1; // direction
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, startmiddleleft);
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, startmiddleleft);
             break;
         case 10:
-            _tendril = new Tendril(friction, trails, length, dampening, tension, -1, -1, wxPoint(manualx * buffer.BufferWi / 100, manualy * buffer.BufferHt / 100));
+            _tendril = new Tendril(cache, friction, trails, length, dampening, tension, -1, -1, wxPoint(manualx * buffer.BufferWi / 100, manualy * buffer.BufferHt / 100));
             break;
         }
     }
@@ -650,7 +698,7 @@ void TendrilEffect::Render(RenderBuffer& buffer, const std::string& movement,
         case 1:
             // random
             if (_tendril != nullptr) {
-                _tendril->UpdateRandomMove(tunemovement, buffer.BufferWi, buffer.BufferHt);
+                _tendril->UpdateRandomMove(cache, tunemovement, buffer.BufferWi, buffer.BufferHt);
             }
             break;
         case 2:
diff --git a/xLights/effects/TendrilEffect.h b/xLights/effects/TendrilEffect.h
index 72f838c2b..45516db2d 100644
--- a/xLights/effects/TendrilEffect.h
+++ b/xLights/effects/TendrilEffect.h
@@ -37,54 +37,6 @@ class wxString;
 #define TENDRIL_OFFSETY_MIN -100
 #define TENDRIL_OFFSETY_MAX 100
 
-class TendrilNode
-{
-    public:
-    float x;
-    float y;
-    float vx;
-    float vy;
-
-    TendrilNode(float x_, float y_);
-    wxPoint* Point();
-};
-
-class ATendril
-{
-    float _friction;
-	size_t _size;
-	float _dampening;
-	float _tension;
-	float _spring;
-	size_t _thickness;
-    int _lastWidth = -1;
-    int _lastHeight = -1;
-
-    std::list<TendrilNode*> _nodes;
-
-	public:
-
-	~ATendril();
-	ATendril(float friction, int size, float dampening, float tension, float spring, const wxPoint& start);
-    void Update(wxPoint* target, int tunemovement, int width, int height);
-	void Draw(PathDrawingContext* gc, xlColor colour, int thickness);
-	wxPoint* LastLocation();
-};
-
-class Tendril
-{
-	std::list<ATendril*> _tendrils;
-
-	public:
-
-	~Tendril();
-	Tendril(float friction, int trails, int size, float dampening, float tension, float springbase, float springincr, const wxPoint& start);
-	void UpdateRandomMove(int tunemovement, int width, int height);
-    void Update(wxPoint* target, int tunemovement, size_t width, size_t height);
-    void Update(int x, int y, int tunemovement, size_t width, size_t height);
-    void Draw(PathDrawingContext* gc, xlColor colour, int thickness);
-};
-
 class TendrilEffect : public RenderableEffect
 {
 public:
diff --git a/xLights/effects/TwinkleEffect.cpp b/xLights/effects/TwinkleEffect.cpp
index dc1aca9ce..75fda9d1f 100644
--- a/xLights/effects/TwinkleEffect.cpp
+++ b/xLights/effects/TwinkleEffect.cpp
@@ -27,10 +27,6 @@
 #include <random>
 #include <cmath>
 
-static std::random_device rd;
-static std::default_random_engine eng{ rd() };
-static std::uniform_int_distribution<> dist(0, INT_MAX);
-
 TwinkleEffect::TwinkleEffect(int id) : RenderableEffect(id, "Twinkle", twinkle_16, twinkle_24, twinkle_32, twinkle_48, twinkle_64)
 {
     //ctor
@@ -55,7 +51,7 @@ public:
     bool isByNode = false;
 };
 
-class TwinkleRenderCache : public EffectRenderCache {
+class TwinkleRenderCache : public EffectRenderStatePRNG {
 public:
     TwinkleRenderCache() {};
     virtual ~TwinkleRenderCache() {};
@@ -185,23 +181,24 @@ int TwinkleEffect::DrawEffectBackground(const Effect *e, int x1, int y1, int x2,
     return 1;
 }
 
-static void place_twinkles(int lights_to_place, int &curIndex, std::vector<StrobeClass>& strobe, RenderBuffer& buffer,
-                           int max_modulo, size_t colorcnt) {
+static void place_twinkles(int lights_to_place, int &curIndex, std::vector<StrobeClass>& strobe, TwinkleRenderCache *cache,
+                           int max_modulo, size_t colorcnt)
+{
     while (lights_to_place > 0 && (curIndex < strobe.size())) {
-        int idx = dist(eng) % (strobe.size() - curIndex) + curIndex;
+        int idx = cache->prngint(strobe.size() - curIndex) + curIndex;
         if (idx != curIndex) {
             std::swap(strobe[idx], strobe[curIndex]);
         }
-        strobe[curIndex].duration = dist(eng) % max_modulo;
-        strobe[curIndex].colorindex = dist(eng) % colorcnt;
+        strobe[curIndex].duration = cache->prngint(max_modulo);
+        strobe[curIndex].colorindex = cache->prngint(colorcnt);
         strobe[curIndex].strobing = true;
         curIndex++;
         lights_to_place--;
     }
 }
 
-void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderBuffer &buffer) {
-    
+void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderBuffer &buffer)
+{   
     float oset = buffer.GetEffectTimeIntervalPosition();
     int Count = GetValueCurveInt("Twinkle_Count", 3, SettingsMap, oset, TWINKLE_COUNT_MIN, TWINKLE_COUNT_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
     int Steps = GetValueCurveInt("Twinkle_Steps", 30, SettingsMap, oset, TWINKLE_STEPS_MIN, TWINKLE_STEPS_MAX, buffer.GetStartTimeMS(), buffer.GetEndTimeMS());
@@ -249,6 +246,7 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
         cache->num_lights = lights;
         cache->lights_to_renew = lights;
         cache->curNumStrobe = 0;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     std::vector<StrobeClass> &strobe = cache->strobe;
 
@@ -266,6 +264,7 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
     int i = 0;
 
     if (buffer.needToInit) {
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         buffer.needToInit = false;
         cache->lights_to_renew = lights;
         cache->curNumStrobe = 0;
@@ -295,7 +294,7 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
             }
             //randomize the locations
             for (int s = 0; s < strobe.size(); ++s) {
-                int r = dist(eng) % strobe.size();
+                int r = cache->prngint(strobe.size());
                 if (r != s) {
                     std::swap(strobe[r], strobe[s]);
                 }
@@ -308,13 +307,13 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
                     if (i % step == 1 || step == 1) {
                         int s = strobe.size();
                         strobe.resize(s + 1);
-                        strobe[s].duration = dist(eng) % max_modulo;
+                        strobe[s].duration = cache->prngint(max_modulo);
 
                         strobe[s].x = i;
                         strobe[s].y = 0;
                         strobe[s].isByNode = true;
 
-                        strobe[s].colorindex = dist(eng) % colorcnt;
+                        strobe[s].colorindex = cache->prngint(colorcnt);
                         cache->curNumStrobe++;
                     }
                 }
@@ -325,13 +324,13 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
                         if (i % step == 1 || step == 1) {
                             int s = strobe.size();
                             strobe.resize(s + 1);
-                            strobe[s].duration = dist(eng) % max_modulo;
+                            strobe[s].duration = cache->prngint(max_modulo);
 
                             strobe[s].x = x;
                             strobe[s].y = y;
                             strobe[s].isByNode = false;
 
-                            strobe[s].colorindex = dist(eng) % colorcnt;
+                            strobe[s].colorindex = cache->prngint(colorcnt);
                             cache->curNumStrobe++;
                         }
                     }
@@ -356,7 +355,7 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
                     }
                 }
             }
-            place_twinkles(cache->lights_to_renew, cache->curNumStrobe, strobe, buffer, max_modulo, colorcnt);
+            place_twinkles(cache->lights_to_renew, cache->curNumStrobe, strobe, cache, max_modulo, colorcnt);
             cache->lights_to_renew = 0;
         }
     }
@@ -377,8 +376,8 @@ void TwinkleEffect::Render(Effect *effect, const SettingsMap &SettingsMap, Rende
                 cache->lights_to_renew++;
                 strobe[x].strobing = false;
             } else if (reRandomize) {
-                strobe[x].duration -= dist(eng) % max_modulo2;
-                strobe[x].colorindex = dist(eng) % colorcnt;
+                strobe[x].duration -= cache->prngint(max_modulo2);
+                strobe[x].colorindex = cache->prngint(colorcnt);
             }
         }
         int i7 = strobe[x].duration;
diff --git a/xLights/effects/VUMeterEffect.cpp b/xLights/effects/VUMeterEffect.cpp
index 2606534c0..7bb81d2ef 100644
--- a/xLights/effects/VUMeterEffect.cpp
+++ b/xLights/effects/VUMeterEffect.cpp
@@ -278,7 +278,7 @@ void VUMeterEffect::Render(Effect* effect, const SettingsMap& SettingsMap, Rende
            SettingsMap.GetBool("CHECKBOX_Regex", false));
 }
 
-class VUMeterRenderCache : public EffectRenderCache
+class VUMeterRenderCache : public EffectRenderStatePRNG
 {
 
 public:
@@ -537,6 +537,7 @@ void VUMeterEffect::Render(RenderBuffer &buffer, SequenceElements *elements, int
 	if (cache == nullptr) {
 		cache = new VUMeterRenderCache();
 		buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
 	}
 	std::list<int>& _timingmarks = cache->_timingmarks;
 	int &_lasttimingmark = cache->_lasttimingmark;
@@ -552,6 +553,7 @@ void VUMeterEffect::Render(RenderBuffer &buffer, SequenceElements *elements, int
 	if (buffer.needToInit)
 	{
         buffer.needToInit = false;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
         _lineHistory.clear();
         _nCount = 0;
         _colourindex = -1;
@@ -2730,9 +2732,10 @@ void VUMeterEffect::RenderLevelBarFrame(RenderBuffer &buffer, int bars, int sens
             }
 
             if (random && bars > 2) {
+                auto cache = static_cast<VUMeterRenderCache*>(buffer.infoCache[id]);
                 int lb = lastbar;
                 while (lb == (int)lastbar) {
-                    lastbar = 1 + rand01() * bars;
+                    lastbar = 1 + cache->prnguniform() * bars;
                 }
                 if (lastbar > bars) lastbar = 1;
             }
@@ -2773,9 +2776,10 @@ void VUMeterEffect::RenderTimingEventBarFrame(RenderBuffer& buffer, int bars, st
             }
 
             if (random && bars > 2) {
+                auto cache = static_cast<VUMeterRenderCache*>(buffer.infoCache[id]);
                 int lb = lastbar;
                 while (lb == (int)lastbar) {
-                    lastbar = 1 + rand01() * bars;
+                    lastbar = 1 + cache->prnguniform() * bars;
                 }
                 if (lastbar > bars + 1)
                     lastbar = 1;
@@ -2861,9 +2865,10 @@ void VUMeterEffect::RenderNoteLevelBarFrame(RenderBuffer &buffer, int bars, int
             }
 
             if (random && bars > 2) {
+                auto cache = static_cast<VUMeterRenderCache*>(buffer.infoCache[id]);
                 int lb = lastbar;
                 while (lb == (int)lastbar) {
-                    lastbar = 1 + rand01() * bars;
+                    lastbar = 1 + cache->prnguniform() * bars;
                 }
                 if (lastbar > bars) lastbar = 1;
             }
diff --git a/xLights/effects/WaveEffect.cpp b/xLights/effects/WaveEffect.cpp
index 655695805..cf77d5e50 100644
--- a/xLights/effects/WaveEffect.cpp
+++ b/xLights/effects/WaveEffect.cpp
@@ -78,7 +78,7 @@ void WaveEffect::adjustSettings(const std::string& version, Effect* effect, bool
 #endif
 
 
-class WaveRenderCache : public EffectRenderCache {
+class WaveRenderCache : public EffectRenderStatePRNG {
 public:
     WaveRenderCache() {};
     virtual ~WaveRenderCache() {};
@@ -154,6 +154,7 @@ void WaveEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderBu
     if (cache == nullptr) {
         cache = new WaveRenderCache();
         buffer.infoCache[id] = cache;
+        cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
     }
     std::vector<int> &WaveBuffer0 = cache->WaveBuffer;
 
@@ -178,20 +179,23 @@ void WaveEffect::Render(Effect *effect, const SettingsMap &SettingsMap, RenderBu
         if (r < 0) r = 0; //turn into straight line; don't completely disappear
     } else if (WaveType == WAVETYPE_IVYFRACTAL) { //generate branches at start of effect
         if (buffer.needToInit || (WaveBuffer0.size() != NumberWaves * buffer.BufferWi)) {
+            if (buffer.needToInit) {
+                cache->seedConsistently(buffer.curPeriod, buffer.BufferWi, buffer.BufferHt, buffer.GetModelName().c_str(), id);
+            }
             r = 0;
             debug(10, "regen wave path, state %0.1f", state);
             int delay = 0;
             int delta = 0; //next branch length, angle
             WaveBuffer0.resize(NumberWaves * buffer.BufferWi);
             for (int x1 = 0; x1 < NumberWaves * buffer.BufferWi; ++x1) {
-                //                if (delay < 1) angle = (rand() % 45) - 22.5;
+                //                if (delay < 1) angle = (cache->prngint(45)) - 22.5;
                 //                int xx = WaveDirection? NumberWaves * BufferWi - x - 1: x;
                 WaveBuffer0[x1] = (delay-- > 0) ? WaveBuffer0[x1 - 1] + delta : 2 * yc;
                 if (WaveBuffer0[x1] >= 2 * buffer.BufferHt) { delta = -2; WaveBuffer0[x1] = 2 * buffer.BufferHt - 1; if (delay > 1) delay = 1; }
                 if (WaveBuffer0[x1] < 0) { delta = 2; WaveBuffer0[x1] = 0; if (delay > 1) delay = 1; }
                 if (delay < 1) {
-                    delta = (rand() % 7) - 3;
-                    delay = 2 + (rand() % 3);
+                    delta = (cache->prngint(7)) - 3;
+                    delay = 2 + (cache->prngint(3));
                 }
             }
             buffer.needToInit = false;
diff --git a/xLights/models/Model.cpp b/xLights/models/Model.cpp
index c40629773..c678d69d9 100644
--- a/xLights/models/Model.cpp
+++ b/xLights/models/Model.cpp
@@ -3000,8 +3000,12 @@ void Model::SetFromXml(wxXmlNode* ModelNode, bool zb)
     InitModel();
 
     size_t NodeCount = GetNodeCount();
+
+    // Sparkles are determined in advance
+    EffectRenderStatePRNG prng;
+    prng.seedConsistently(StartChannel, 0, NumberOfStrings, name.c_str(), 0);
     for (size_t i = 0; i < NodeCount; i++) {
-        Nodes[i]->sparkle = rand() % 10000;
+        Nodes[i]->sparkle = prng.prngint(10000);
     }
 
     wxXmlNode* f = ModelNode->GetChildren();
