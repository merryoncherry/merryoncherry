diff --git a/xLights/SubModelsDialog.cpp b/xLights/SubModelsDialog.cpp
index 01af4b3f3..252328751 100644
--- a/xLights/SubModelsDialog.cpp
+++ b/xLights/SubModelsDialog.cpp
@@ -26,10 +26,11 @@
  //*)
 
 #include <wx/dnd.h>
-#include <wx/msgdlg.h>
 #include <wx/menu.h>
-#include <wx/tokenzr.h>
+#include <wx/mimetype.h>
+#include <wx/msgdlg.h>
 #include <wx/numdlg.h>
+#include <wx/tokenzr.h>
 
 #include "SubModelsDialog.h"
 #include "models/Model.h"
@@ -100,8 +101,25 @@ const long SubModelsDialog::SUBMODEL_DIALOG_FLIP_HOR = wxNewId();
 const long SubModelsDialog::SUBMODEL_DIALOG_FLIP_VER = wxNewId();
 const long SubModelsDialog::SUBMODEL_DIALOG_REVERSE = wxNewId();
 const long SubModelsDialog::SUBMODEL_DIALOG_JOIN = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_JOIN_SS = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_SPLIT = wxNewId();
 const long SubModelsDialog::SUBMODEL_DIALOG_SORT_BY_NAME = wxNewId();
 const long SubModelsDialog::SUBMODEL_DIALOG_REMOVE_DUPLICATE = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_ELIDE_DUPLICATE = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_SORT_POINTS = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_LR = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_TB = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_LR = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_TB = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_EVEN_ROWS = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_PIVOT_ROWS_COLUMNS = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_SYMMETRIZE = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_SORT_POINTS_ALL = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_COMBINE_STRANDS = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_EXPAND_STRANDS_ALL = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_COMPRESS_STRANDS_ALL = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_BLANKS_AS_ZERO = wxNewId();
+const long SubModelsDialog::SUBMODEL_DIALOG_BLANKS_AS_EMPTY = wxNewId();
 
 BEGIN_EVENT_TABLE(SubModelsDialog,wxDialog)
 	//(*EventTable(SubModelsDialog)
@@ -860,10 +878,17 @@ void SubModelsDialog::OnExportBtnPopup(wxCommandEvent& event)
 void SubModelsDialog::OnListPopup(wxCommandEvent& event)
 {
     if (event.GetId() == SUBMODEL_DIALOG_JOIN) {
-        JoinSelectedModels();
-    } else if (event.GetId() == SUBMODEL_DIALOG_SORT_BY_NAME) {
+        JoinSelectedModels(false);
+    }
+    else if (event.GetId() == SUBMODEL_DIALOG_JOIN_SS) {
+        JoinSelectedModels(true);
+    }
+    else if (event.GetId() == SUBMODEL_DIALOG_SORT_BY_NAME) {
         SortSubModelsByName();
     }
+    else if (event.GetId() == SUBMODEL_DIALOG_SPLIT) {
+        SplitSelectedSubmodel();
+    }
 }
 
 void SubModelsDialog::OnNodesGridCellChange(wxGridEvent& event)
@@ -951,21 +976,100 @@ void SubModelsDialog::OnNodesGridLabelLeftClick(wxGridEvent& event)
 
 void SubModelsDialog::OnNodesGridCellRightClick(wxGridEvent& event)
 {
+    wxMenu mnu;
     if (event.GetRow() != -1) {
         //NodesGrid->GoToCell(event.GetRow(), 0);
-        wxMenu mnu;
 
         mnu.Append(SUBMODEL_DIALOG_REMOVE_DUPLICATE, "Remove Duplicates");
-
-        mnu.Connect(wxEVT_MENU, (wxObjectEventFunction)&SubModelsDialog::OnNodesGridPopup, nullptr, this);
-        PopupMenu(&mnu);
-    }
+        mnu.Append(SUBMODEL_DIALOG_ELIDE_DUPLICATE, "Elide Duplicates");
+        mnu.Append(SUBMODEL_DIALOG_SORT_POINTS, "Sort Strand Points Geometrically...");
+        mnu.AppendSeparator();
+    }
+    mnu.Append(SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_LR, "Remove Duplicates All Left->Right");
+    mnu.Append(SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_TB, "Remove Duplicates All Top->Bottom");
+    mnu.Append(SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_LR, "Elide Duplicates All Left->Right");
+    mnu.Append(SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_TB, "Elide Duplicates All Top->Bottom");
+    mnu.Append(SUBMODEL_DIALOG_EVEN_ROWS, "Uniform Row Length");
+    mnu.Append(SUBMODEL_DIALOG_PIVOT_ROWS_COLUMNS, "Pivot Rows / Columns");
+    mnu.Append(SUBMODEL_DIALOG_SORT_POINTS_ALL, "Geometrically Sort Points All Strands...");
+
+    mnu.AppendSeparator();
+    mnu.Append(SUBMODEL_DIALOG_SYMMETRIZE, "Symmetrize (Rotational)");
+    mnu.Append(SUBMODEL_DIALOG_COMBINE_STRANDS, "Combine Strands");
+    
+    mnu.AppendSeparator();
+    mnu.Append(SUBMODEL_DIALOG_EXPAND_STRANDS_ALL, "Expand All Strands");
+    mnu.Append(SUBMODEL_DIALOG_COMPRESS_STRANDS_ALL, "Compress All Strands");
+    mnu.Append(SUBMODEL_DIALOG_BLANKS_AS_ZERO, "Convert Blanks To Zeros");
+    mnu.Append(SUBMODEL_DIALOG_BLANKS_AS_EMPTY, "Convert Zeros To Empty");
+
+    mnu.Connect(wxEVT_MENU, (wxObjectEventFunction)&SubModelsDialog::OnNodesGridPopup, nullptr, this);
+    PopupMenu(&mnu);
 }
 
 void SubModelsDialog::OnNodesGridPopup(wxCommandEvent& event)
 {
     if (event.GetId() == SUBMODEL_DIALOG_REMOVE_DUPLICATE) {
-        RemoveDuplicates();
+        RemoveDuplicates(false);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_ELIDE_DUPLICATE) {
+        RemoveDuplicates(true);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_LR) {
+        RemoveAllDuplicates(true, false);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_TB) {
+        RemoveAllDuplicates(false, false);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_LR) {
+        RemoveAllDuplicates(true, true);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_TB) {
+        RemoveAllDuplicates(false, true);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_EVEN_ROWS) {
+        MakeRowsUniform();
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_PIVOT_ROWS_COLUMNS) {
+        PivotRowsColumns();
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_SYMMETRIZE) {
+        Symmetrize();
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_SORT_POINTS) {
+        OrderPoints(false);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_SORT_POINTS_ALL) {
+        OrderPoints(true);
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_COMBINE_STRANDS) {
+        CombineStrands();
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_EXPAND_STRANDS_ALL) {
+        processAllStrands([](wxString str) { return ExpandNodes(str); });
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_COMPRESS_STRANDS_ALL) {
+        processAllStrands([](wxString str) { return CompressNodes(str); });
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_BLANKS_AS_ZERO) {
+        processAllStrands([](wxString str) {
+            auto ns = wxSplit(str, ',');
+            for (auto i = ns.begin(); i != ns.end(); ++i) {
+                if (*i == "")
+                    *i = "0";
+            }
+            return wxJoin(ns, ',');
+        });
+    }
+    if (event.GetId() == SUBMODEL_DIALOG_BLANKS_AS_EMPTY) {
+        processAllStrands([](wxString str) {
+            auto ns = wxSplit(str, ',');
+            for (auto i = ns.begin(); i != ns.end(); ++i) {
+                if (*i == "0")
+                    *i = "";
+            }
+            return wxJoin(ns, ',');
+        });
     }
 }
 
@@ -978,6 +1082,11 @@ void SubModelsDialog::OnListCtrl_SubModelsItemRClick(wxListEvent& event)
         if (ListCtrl_SubModels->GetSelectedItemCount() > 1) {
             mnu.AppendSeparator();
             mnu.Append(SUBMODEL_DIALOG_JOIN, "Join");
+            mnu.Append(SUBMODEL_DIALOG_JOIN_SS, "Join Single Strand");
+        }
+        if (ListCtrl_SubModels->GetSelectedItemCount() == 1) {
+            mnu.AppendSeparator();
+            mnu.Append(SUBMODEL_DIALOG_SPLIT, "Split");
         }
 
         mnu.Connect(wxEVT_MENU, (wxObjectEventFunction)&SubModelsDialog::OnListPopup, nullptr, this);
@@ -1111,6 +1220,767 @@ void SubModelsDialog::OnButton_SearchClick(wxCommandEvent& event)
     }
 }
 
+static void LogAndWrite(wxFile& f, const std::string& msg)
+{
+    static log4cpp::Category& logger_base = log4cpp::Category::getInstance(std::string("log_base"));
+    logger_base.debug("CheckSequence: " + msg);
+    if (f.IsOpened()) {
+        f.Write(msg + "\r\n");
+    }
+}
+
+void SubModelsDialog::Symmetrize()
+{
+    // Validate that we have something to work on
+    wxString mname = GetSelectedName();
+    if (mname.empty()) {
+        return;
+    }
+
+    int row = NodesGrid->GetGridCursorRow();
+
+    SubModelInfo* sm = GetSubModelInfo(mname);
+    if (!sm)
+        return;
+
+    // Get user input
+    wxNumberEntryDialog dlg(this, "Degree of Symmetry", "", "Select Degree of Rotational Symmetry", 8, 2, 100);
+    if (dlg.ShowModal() != wxID_OK) {
+        return;
+    }
+    int dos = dlg.GetValue();
+
+    wxFile f;
+    wxString filename = wxFileName::CreateTempFileName("xLightsSymmetrize") + ".txt";
+
+    bool writeToFile = true;
+    bool displayInEditor = true;
+
+    if (writeToFile || displayInEditor) {
+        f.Open(filename, wxFile::write);
+        if (!f.IsOpened()) {
+            DisplayError("Unable to create results file for Symmetrize. Aborted.", this);
+            return;
+        }
+    }
+
+    int w, h;
+    modelPreview->GetSize(&w, &h);
+
+    LogAndWrite(f, wxString::Format("Processing model: %s", mname.c_str()));
+    LogAndWrite(f, wxString::Format("Symmetrize DoS: %d", dos));
+    LogAndWrite(f, wxString::Format("Model Dimensions (based on screen): %dx%d", w, h));
+
+    //  Calculate point xys
+    std::map<int, std::pair<float, float>> coords;
+    if (!model->GetScreenLocations(modelPreview, coords)) {
+        DisplayError("Model doesn't have precisely one location per node");
+        return;
+    }
+    LogAndWrite(f, wxString::Format("Number of nodes: %d", int(coords.size())));
+
+    //  Calculate centroid
+    if (coords.empty())
+        return;
+    float cx = 0, cy = 0;
+    std::vector<float> xsv, ysv;
+    for (const auto& x : coords) {
+        cx += x.second.first;
+        cy += x.second.second;
+        xsv.push_back(x.second.first);
+        ysv.push_back(x.second.second);
+    }
+    cx /= float(coords.size());
+    cy /= float(coords.size());
+    LogAndWrite(f, wxString::Format("Centroid: %f, %f", cx, cy));
+
+    //  Calculate radius / centroid another way
+    float nx = cx, ny = cy, xx = cx, xy = cy;
+    float varx = 0, vary = 0;
+    for (const auto& x : coords) {
+        nx = std::min(nx, x.second.first);
+        xx = std::max(xx, x.second.first);
+        ny = std::min(ny, x.second.second);
+        xy = std::max(xy, x.second.second);
+
+        varx += (x.second.first - cx) * (x.second.first - cx);
+        vary += (x.second.second - cy) * (x.second.second - cy);
+    }
+    LogAndWrite(f, wxString::Format("Ranges x:%.1f-%.1f, y:%1f-%1f", nx, xx, ny, xy));
+    float clx = (nx + xx) / 2;
+    float cly = (ny + xy) / 2;
+    LogAndWrite(f, wxString::Format("Center by extremity: %f, %f", clx, cly));
+    if (false) {
+        cx = clx;
+        cy = cly;
+    }
+
+    // And another
+    std::sort(xsv.begin(), xsv.end());
+    std::sort(ysv.begin(), ysv.end());
+    float mcx, mcy;
+    if (xsv.size() % 2 == 1) {
+        mcx = xsv[xsv.size() / 2];
+        mcy = ysv[ysv.size() / 2];
+    } else {
+        mcx = (xsv[xsv.size() / 2] + xsv[xsv.size() / 2 + 1]) / 2;
+        mcy = (ysv[ysv.size() / 2] + ysv[ysv.size() / 2 + 1]) / 2;
+    }
+    LogAndWrite(f, wxString::Format("Center by median: %f, %f", mcx, mcy));
+
+    float dlx = xx - nx;
+    float dly = xy - ny;
+    if (dlx > 0 && dly > 0) {
+        float aspectx = dlx / std::max(dlx, dly);
+        float aspecty = dly / std::max(dlx, dly);
+
+        LogAndWrite(f, wxString::Format("Aspect ratio by extremity: %f / %f", aspectx, aspecty));
+
+        if (true) {
+            // Variance-based aspect ratio
+            float mvar = std::max(varx, vary);
+            aspectx = sqrtf(varx / mvar);
+            aspecty = sqrtf(vary / mvar);
+            LogAndWrite(f, wxString::Format("Aspect Ratio by variance: %f / %f", aspectx, aspecty));
+        }
+
+        if (aspectx < .98 || aspecty < .98) {
+            wxArrayString chs;
+            chs.push_back("Yes");
+            chs.push_back("No");
+            wxSingleChoiceDialog dlg(this, "Squarify aspect ratio?", "Aspect Ratio", chs);
+            dlg.ShowModal();
+            if (dlg.GetStringSelection() == "Yes") {
+                for (auto& pt : coords) {
+                    pt.second.first = (pt.second.first - cx) * aspecty + cx;
+                    pt.second.second = (pt.second.second - cy) * aspectx + cy;
+                }
+            }
+        }
+    }
+
+    bool handleCenterNode = false;
+    if (coords.size() % dos == 1) {
+        wxArrayString chs;
+        chs.push_back("Yes");
+        chs.push_back("No");
+        wxSingleChoiceDialog dlg(this, "Shoud a center node be identified?", "Center Node", chs);
+        dlg.ShowModal();
+        if (dlg.GetStringSelection() == "Yes") {
+            handleCenterNode = true;
+        }
+    }
+
+    //  Calculate locations in new space
+    std::map<int, std::pair<float, float>> fcoords1, fcoords2;
+    std::map<int, float> fturns;
+    for (const auto& p : coords) {
+        float dx = p.second.first - cx;
+        float dy = p.second.second - cy;
+        if (dx == 0 && dy == 0) {
+            fcoords1[p.first] = std::make_pair(cx, cy);
+            fturns[p.first] = 0;
+            continue;
+        }
+        float rad = sqrtf(dx * dx + dy * dy);
+        float ang = atan2f(dy, dx);
+        if (ang <= 0) {
+            ang += float(2 * PI);
+        }
+        ang *= float(dos);
+        float turn = float(ang / (2 * PI)); // Which trip around?  We want one from each trip.
+        if (turn >= dos)
+            turn -= dos;
+        fturns[p.first] = turn;
+        while (ang >= 2 * PI)
+            ang -= float(2 * PI);
+        ang /= float(dos);
+        fcoords1[p.first] = std::make_pair(rad * cosf(ang) + cx, rad * sinf(ang) + cy);
+        if (ang < PI / dos / 2)
+            ang += 2 * PI / dos;
+        fcoords2[p.first] = std::make_pair(rad * cosf(ang) + cx, rad * sinf(ang) + cy);
+    }
+    LogAndWrite(f, wxString::Format("Transformed nodes: %d", int(fcoords1.size())));
+
+    //  Build list that need matched, and match list
+    std::set<int> nodesNeedMatch;
+    std::map<int, std::vector<int>> matchIDToNodeSet; // vector index is relative turn #
+    std::map<int, int> nodeToMatchIDs;
+
+    // Copy and expand data
+    int origStrands = sm->strands.size();
+    size_t mlen = 0;
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        auto x = wxSplit(ExpandNodes(sm->strands[sm->strands.size() - 1 - i]), ',');
+        for (auto n : x) {
+            if (n == "" || n == "0")
+                continue;
+            nodesNeedMatch.insert(wxAtoi(n));
+        }
+    }
+
+    // Handle the business of a center node, if any
+    if (handleCenterNode) {
+        bool first = true;
+        float ndst = 0;
+        int nnode = -1;
+        for (const auto& pt : coords) {
+            float dx = pt.second.first - cx;
+            float dy = pt.second.second - cy;
+            float dst = dx * dx + dy * dy;
+            if (first || dst < ndst) {
+                ndst = dst;
+                nnode = pt.first;
+            }
+            first = false;
+        }
+
+        nodesNeedMatch.erase(nnode);
+        nodeToMatchIDs[nnode] = matchIDToNodeSet.size();
+        matchIDToNodeSet[nodeToMatchIDs[nnode]] = std::vector<int>(dos, nnode);
+    }
+
+    int radius = 0;
+    //  For each of numerous search radii, calculate list per grid cell
+    //  We will stop if all nodes have matches
+    while (!nodesNeedMatch.empty()) {
+        std::vector<std::vector<std::vector<int>>> bins; // [x][y][which]
+        for (int x = 0; x < w; ++x) {
+            bins.push_back(std::vector<std::vector<int>>());
+            for (int y = 0; y < h; ++y) {
+                bins[x].push_back(std::vector<int>());
+            }
+        }
+
+        // Append to lists
+        for (const auto& pt : fcoords1) {
+            if (nodeToMatchIDs.count(pt.first))
+                continue; // Already matched
+
+            int bx = int(pt.second.first);
+            int by = int(pt.second.second);
+            for (int x = bx - radius; x <= bx + radius; ++x) {
+                if (x < 0 || x >= w)
+                    continue;
+                for (int y = by - radius; y <= by + radius; ++y) {
+                    if (y < 0 || y >= h)
+                        continue;
+                    bins[x][y].push_back(pt.first);
+                }
+            }
+        }
+        // Add redundant copy of some - should check if already in bin?
+        for (const auto& pt : fcoords2) {
+            if (nodeToMatchIDs.count(pt.first))
+                continue; // Already matched
+
+            int bx = int(pt.second.first);
+            int by = int(pt.second.second);
+            for (int x = bx - radius; x <= bx + radius; ++x) {
+                if (x < 0 || x >= w)
+                    continue;
+                for (int y = by - radius; y <= by + radius; ++y) {
+                    if (y < 0 || y >= h)
+                        continue;
+                    bins[x][y].push_back(pt.first);
+                }
+            }
+        }
+
+        // See if any lists are ready
+        for (int x = 0; x < w; ++x) {
+            for (int y = 0; y < h; ++y) {
+                if (int(bins[x][y].size()) < dos)
+                    continue; // Quick test without looking at bins closely, not enough here
+                std::vector<std::pair<float, int>> matches;
+                for (int pt : bins[x][y]) {
+                    if (nodeToMatchIDs.count(pt) != 0)
+                        continue; // Already matched this pass
+                    matches.push_back(std::make_pair(fturns[pt], pt));
+                }
+                if (matches.size() < dos)
+                    continue;
+                std::sort(matches.begin(), matches.end()); // Sort CCW
+
+                // Try to pick
+                float tgt = matches[0].first;
+                int found = 0;
+                for (unsigned j = 0; j < matches.size(); ++j) {
+                    if (matches[j].first >= tgt - .5 && matches[j].first <= tgt + .5) {
+                        ++found;
+                        tgt += 1;
+                    }
+                    if (found == dos)
+                        break;
+                }
+                if (found != dos)
+                    continue; // On closer inspection, nope
+
+                // OK, repeat that process and record it
+                std::vector<int> matched;
+                tgt = matches[0].first;
+                int mid = matchIDToNodeSet.size();
+                for (unsigned j = 0; j < matches.size(); ++j) {
+                    if (matches[j].first >= tgt - .5 && matches[j].first <= tgt + .5) {
+                        ++found;
+                        tgt += 1;
+                        matched.push_back(matches[j].second);
+                        nodeToMatchIDs[matches[j].second] = mid;
+                        nodesNeedMatch.erase(matches[j].second);
+                    }
+                    if (found == dos)
+                        break;
+                }
+                matchIDToNodeSet[mid] = matched;
+
+                LogAndWrite(f, wxString::Format("Found Match for %d at radius %d", matched[0], radius));
+                for (auto n : matched) {
+                    LogAndWrite(f, wxString::Format("    Member %d", n));
+                }
+            }
+        }
+
+        // Sanity
+        ++radius;
+        if (radius > 20 && !nodesNeedMatch.empty()) {
+            LogAndWrite(f, wxString::Format("Maximum search radius hit: %d", radius));
+            break;
+        }
+
+        wxSafeYield();
+    }
+
+    bool fail = false;
+    // Report any trouble
+    if (!nodesNeedMatch.empty()) {
+        LogAndWrite(f, "Note the following nodes could not be matched.  Ensure that zoom in/out is reasonable, that the model is centered, and that the point locations are clean.");
+        for (auto x : nodesNeedMatch) {
+            LogAndWrite(f, wxString::Format("  Node %d", x));
+        }
+        fail = true;
+    }
+
+    // Use match list to make new strands
+    for (int t = 1; !fail && t < dos; ++t) {
+        for (int sn = 0; sn < origStrands; ++sn) {
+            bool first = true;
+            // auto x = wxSplit(ExpandNodes(sm->strands[sm->strands.size() - 1 - sn]), ',');
+            auto x = wxSplit(ExpandNodes(sm->strands[sn]), ',');
+            wxString str;
+            for (auto n : x) {
+                if (first) {
+                    first = false;
+                } else {
+                    str += ",";
+                }
+                if (n == "" || n == "0")
+                    continue;
+                int nn = wxAtoi(n);
+                // Find it
+                auto& matchs = matchIDToNodeSet[nodeToMatchIDs[nn]];
+                for (int ii = 0; ii < dos; ++ii) {
+                    if (matchs[ii] == nn) {
+                        int mapn = matchs[(ii + t) % dos];
+                        str += wxString::Format("%d", mapn);
+                        break;
+                    }
+                }
+            }
+            sm->strands.push_back(CompressNodes(str));
+        }
+    }
+
+    // Update UI
+    Select(GetSelectedName());
+
+    if (row >= 0) {
+        NodesGrid->SetGridCursor(row, 0);
+    }
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+
+    // Save / Display results log
+    if (f.IsOpened()) {
+        f.Close();
+    }
+
+    if (fail) {
+        DisplayError("Symmetrize encountered errors.  See log for details.", this);
+
+        if (displayInEditor) {
+            wxFileType* ft = wxTheMimeTypesManager->GetFileTypeFromExtension("txt");
+            if (ft != nullptr) {
+                wxString command = ft->GetOpenCommand(filename);
+
+                if (command == "") {
+                    DisplayError(wxString::Format("Unable to show xLights Symmetrize results '%s'. See your log for the content.", filename).ToStdString(), this);
+                } else {
+                    wxUnsetEnv("LD_PRELOAD");
+                    wxExecute(command);
+                }
+                delete ft;
+            } else {
+                DisplayError(wxString::Format("Unable to show xLights Symmetrize results '%s'. See your log for the content.", filename).ToStdString(), this);
+            }
+        }
+    }
+}
+
+void SubModelsDialog::processAllStrands(wxString (*func)(wxString))
+{
+    wxString name = GetSelectedName();
+    if (name.empty()) {
+        return;
+    }
+
+    int row = NodesGrid->GetGridCursorRow();
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm)
+        return;
+
+    // Process all rows
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        sm->strands[sm->strands.size() - 1 - i] = func(sm->strands[sm->strands.size() - 1 - i]);
+    }
+
+    // Update UI
+    Select(name);
+
+    if (row >= 0) {
+        NodesGrid->SetGridCursor(row, 0);
+    }
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+}
+
+static wxString OrderPointsI(std::map<int, std::pair<float, float>>& coords, const wxString& instr, std::pair<float, float> centroid, bool radial, float startangle, bool ccw_outside)
+{
+    wxArrayString inp = wxSplit(ExpandNodes(instr), ',');
+
+    std::vector<std::pair<int, int>> nodeAndBlanksBefore;
+    int blanks = 0;
+    for (const auto& x : inp) {
+        if (x == "" || x == "0") {
+            ++blanks;
+        } else {
+            nodeAndBlanksBefore.push_back(std::make_pair(wxAtoi(x), blanks));
+            blanks = 0;
+        }
+    }
+
+    if (radial) {
+        std::sort(nodeAndBlanksBefore.begin(), nodeAndBlanksBefore.end(),
+                  [&coords, &centroid, startangle, ccw_outside](const std::pair<int, int>& l, const std::pair<int, int>& r) {
+                      auto cl = coords[l.first];
+                      auto cr = coords[r.first];
+
+                      float dxl = cl.first - centroid.first;
+                      float dyl = cl.second - centroid.second;
+                      float dxr = cr.first - centroid.first;
+                      float dyr = cr.second - centroid.second;
+
+                      float dl = dxl * dxl + dyl * dyl;
+                      float dr = dxr * dxr + dyr * dyr;
+
+                      // Hum, we could use dot product along angle, instead of distance...
+
+                      return ccw_outside ? (dl > dr) : (dl < dr);
+                  });
+    } else {
+        std::sort(nodeAndBlanksBefore.begin(), nodeAndBlanksBefore.end(),
+                  [&coords, &centroid, startangle, ccw_outside](const auto& l, const auto& r) {
+                      auto cl = coords[l.first];
+                      auto cr = coords[r.first];
+
+                      float angl = atan2(cl.second - centroid.second, cl.first - centroid.first);
+                      float angr = atan2(cr.second - centroid.second, cr.first - centroid.first);
+                      angl -= startangle;
+                      angr -= startangle;
+                      while (angl < 0)
+                          angl += float(2 * PI);
+                      while (angr < 0)
+                          angr += float(2 * PI);
+
+                      return ccw_outside ? (angl < angr) : (angl > angr);
+                  });
+    }
+
+    if (nodeAndBlanksBefore.empty())
+        return instr; // All Empty
+    nodeAndBlanksBefore[0].second += blanks;
+
+    wxString res;
+    for (const auto& x : nodeAndBlanksBefore) {
+        for (int i = 0; i < x.second; ++i)
+            res += ",";
+        res += wxString::Format("%d,", x.first);
+    }
+
+    return CompressNodes(res.substr(0, res.size() - 1));
+}
+
+void SubModelsDialog::OrderPoints(bool wholesub)
+{
+    // Collect up selection
+    wxString name = GetSelectedName();
+    if (name == "") {
+        return;
+    }
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm->isRanges)
+        return;
+    if (sm->strands.empty())
+        return;
+
+    int row = NodesGrid->GetGridCursorRow();
+    if (row < 0 && !wholesub)
+        return;
+
+    // Gather the coordinates
+    std::map<int, std::pair<float, float>> coords;
+    if (!model->GetScreenLocations(modelPreview, coords)) {
+        DisplayError("Model doesn't have precisely one location per node");
+        return;
+    }
+
+    // Gather centroids
+    float wcx = 0, wcy = 0, smcx = 0, smcy = 0;
+    std::set<int> smpts;
+    for (int crow = 0; crow < int(sm->strands.size()); ++crow) {
+        auto arr = wxSplit(ExpandNodes(sm->strands[crow]), ',');
+        for (auto& x : arr) {
+            if (x.empty() || x == "0")
+                continue;
+            smpts.insert(wxAtoi(x));
+        }
+    }
+    if (smpts.empty())
+        return;
+    for (const auto& pt : coords) {
+        wcx += pt.second.first;
+        wcy += pt.second.second;
+        if (smpts.count(pt.first)) {
+            smcx += pt.second.first;
+            smcy += pt.second.second;
+        }
+    }
+    wcx /= coords.size();
+    wcy /= coords.size();
+    smcx /= smpts.size();
+    smcy /= smpts.size();
+
+    // Gather the user's requested action
+    std::pair<float, float> mctr = std::make_pair(wcx, wcy);
+    auto ctr = mctr;
+    bool radial = false;
+    float angle = 0;
+    bool ccw_outside = false;
+    bool strandCentroid = false;
+    bool startModelRelative = false;
+
+    wxArrayString chs;
+    chs.push_back("Circumferential|Start From Model Inside|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Model Inside|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model Inside|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model Inside|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Model Inside|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model Inside|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model Outside|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Model Outside|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model Outside|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model Outside|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Model Outside|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model Outside|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model CCW|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Model CCW|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model CCW|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model CCW|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Model CCW|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model CCW|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model CW|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Model CW|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model CW|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Model CW|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Model CW|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Model CW|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Up|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Up|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Up|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Up|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Up|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Up|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Down|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Down|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Down|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Down|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Down|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Down|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Left|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Left|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Left|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Left|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Left|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Left|CCW Around Strand Center");
+    chs.push_back("Circumferential|Start From Right|CW Around Model Center");
+    chs.push_back("Circumferential|Start From Right|CW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Right|CW Around Strand Center");
+    chs.push_back("Circumferential|Start From Right|CCW Around Model Center");
+    chs.push_back("Circumferential|Start From Right|CCW Around Submodel Center");
+    chs.push_back("Circumferential|Start From Right|CCW Around Strand Center");
+
+    chs.push_back("Radial|From Near To Far|Model Center");
+    chs.push_back("Radial|From Near To Far|Submodel Center");
+    chs.push_back("Radial|From Near To Far|Strand Center");
+    chs.push_back("Radial|From Far To Near|Model Center");
+    chs.push_back("Radial|From Far To Near|Submodel Center");
+    chs.push_back("Radial|From Far To Near|Strand Center");
+
+    wxSingleChoiceDialog dlg(this, "Please choose direction, start/end, and centroid", "Order Type", chs);
+    if (dlg.ShowModal() != wxID_OK) {
+        return;
+    }
+    if (dlg.GetStringSelection() == "Yes") {
+        // handleCenterNode = true;
+    }
+
+    auto choices = wxSplit(dlg.GetStringSelection(), '|');
+    if (choices.size() != 3)
+        return;
+
+    if (choices[0] == "Radial") {
+        radial = true;
+
+        if (choices[2] == "Submodel Center") {
+            ctr = std::make_pair(smcx, smcy);
+        } else if (choices[2] == "Strand Center") {
+            strandCentroid = true;
+        } else if (choices[2] == "Model Center") {
+            // Leave ctr how it is
+        } else {
+            DisplayError(wxString::Format("Unexpected radial center %s", choices[2]), this);
+            return;
+        }
+
+        if (choices[1] == "From Far To Near") {
+            ccw_outside = true;
+        } else if (choices[1] == "From Near To Far") {
+            ccw_outside = false;
+        } else {
+            DisplayError(wxString::Format("Unexpected radial direction %s", choices[1]), this);
+            return;
+        }
+    } else if (choices[0] == "Circumferential") {
+        // Circumferential
+
+        if (choices[2] == "CW Around Model Center") {
+            ccw_outside = false;
+        } else if (choices[2] == "CCW Around Model Center") {
+            ccw_outside = true;
+        } else if (choices[2] == "CW Around Submodel Center") {
+            ctr = std::make_pair(smcx, smcy);
+            ccw_outside = false;
+        } else if (choices[2] == "CCW Around Submodel Center") {
+            ctr = std::make_pair(smcx, smcy);
+            ccw_outside = true;
+        } else if (choices[2] == "CW Around Strand Center") {
+            ccw_outside = false;
+            strandCentroid = true;
+        } else if (choices[2] == "CCW Around Strand Center") {
+            ccw_outside = true;
+            strandCentroid = true;
+        } else {
+            DisplayError(wxString::Format("Unexpected circumferential mode %s", choices[2]), this);
+            return;        
+        }
+
+        float fdlt = 0.02f;
+        if (choices[1] == "Start From Up") {
+            angle = float(PI / 2);
+        } else if (choices[1] == "Start From Down") {
+            angle = float(3 * PI / 2);
+        } else if (choices[1] == "Start From Right") {
+            angle = 0;
+        } else if (choices[1] == "Start From Left") {
+            angle = float(PI);
+        } else if (choices[1] == "Start From Up") {
+            angle = float(PI / 2);
+        } else if (choices[1] == "Start From Model Inside") {
+            angle = 0;
+            startModelRelative = true;
+        } else if (choices[1] == "Start From Model Outside") {
+            angle = float(PI);
+            startModelRelative = true;
+        } else if (choices[1] == "Start From Model CW") {
+            angle = float(PI / 2);
+            startModelRelative = true;
+        } else if (choices[1] == "Start From Model CCW") {
+            angle = float(3*PI/2);
+            startModelRelative = true;
+        } else {
+            DisplayError(wxString::Format("Unexpected circumferential start %s", choices[1]), this);
+            return;
+        }
+        angle += ccw_outside ? -fdlt : fdlt;
+    } else {
+        DisplayError(wxString::Format("Unexpected mode %s", choices[0]), this);
+        return;
+    }
+
+    // Perform the work
+    int minr = 0;
+    int maxr = sm->strands.size() - 1;
+    if (!wholesub) {
+        minr = maxr = row;
+    }
+    for (int crow = minr; crow <= maxr; ++crow) {
+        auto strand = ExpandNodes(sm->strands[sm->strands.size() - 1 - crow]);
+
+        // Calculate strand points
+        float scx = 0, scy = 0;
+        int scnt = 0;
+        auto srr = wxSplit(strand, ',');
+        for (auto s : srr) {
+            if (s.empty() || s == "0")
+                continue;
+            ++scnt;
+            int pt = wxAtoi(s);
+            scx += coords[pt].first;
+            scy += coords[pt].second;
+        }
+        if (scnt == 0)
+            continue;
+        auto sctr = std::make_pair(scx / scnt, scy / scnt);
+
+        if (strandCentroid)
+            ctr = sctr;
+
+        float uangle = angle;
+        if (startModelRelative) {
+            float mangle = atan2f(wcy - sctr.second, wcx - sctr.first);
+            if (mangle < 0)
+                mangle += float(2 * PI);
+            uangle += mangle;
+        }
+
+        strand = OrderPointsI(coords, strand, ctr, radial, uangle, ccw_outside);
+        sm->strands[sm->strands.size() - 1 - crow] = strand;
+    }
+
+    // Update UI
+    Select(GetSelectedName());
+    NodesGrid->SetGridCursor(row >= 0 ? row : 0, 0);
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+    SelectRow(row >= 0 ? row : 0);
+    ValidateWindow();
+}
+
 #pragma endregion actions
 
 void SubModelsDialog::PopulateList()
@@ -2051,7 +2921,7 @@ void SubModelsDialog::OnPreviewLeftUp(wxMouseEvent& event)
         m_bound_end_x = ray_origin.x;
         m_bound_end_y = ray_origin.y;
 
-        SelectAllInBoundingRect(event.ShiftDown());
+        SelectAllInBoundingRect(event.ShiftDown(), event.ControlDown());
         m_creating_bound_rect = false;
 
         modelPreview->ReleaseMouse();
@@ -2172,10 +3042,10 @@ void SubModelsDialog::GetMouseLocation(int x, int y, glm::vec3& ray_origin, glm:
     );
 }
 
-void SubModelsDialog::SelectAllInBoundingRect(bool shiftDwn)
+void SubModelsDialog::SelectAllInBoundingRect(bool shiftDwn, bool ctrlDown)
 {
     if (shiftDwn) {
-        RemoveNodes();
+        RemoveNodes(ctrlDown);
         return;
     }
     wxString name = GetSelectedName();
@@ -2224,7 +3094,7 @@ void SubModelsDialog::SelectAllInBoundingRect(bool shiftDwn)
     ValidateWindow();
 }
 
-void SubModelsDialog::RemoveNodes()
+void SubModelsDialog::RemoveNodes(bool elide)
 {
     wxString name = GetSelectedName();
     if (name == "") {
@@ -2248,10 +3118,21 @@ void SubModelsDialog::RemoveNodes()
 
     for (auto const& newNode : nodes) {
         wxString stNode = wxString::Format("%d", newNode);
-        for (auto it = oldNodeArrray.begin(); it != oldNodeArrray.end(); ++it) {
-            if (*it == stNode) {
-                oldNodeArrray.erase(it);
-                break;
+        if (elide) {
+            // We're going to replace the last one with space (in case it was duplicated)
+            for (auto it = oldNodeArrray.rbegin(); it != oldNodeArrray.rend(); ++it) {
+                if (*it == stNode) {
+                    *it = "";
+                    break;
+                }
+            }            
+        } else {
+            for (auto it = oldNodeArrray.begin(); it != oldNodeArrray.end(); ++it) {
+                if (*it == stNode) {
+                    oldNodeArrray.erase(it);
+                    // Note that this only erases once, in case it somehow got added multiple times...
+                    break;
+                }
             }
         }
     }
@@ -2922,8 +3803,8 @@ void SubModelsDialog::FlipHorizontal()
 
     for (auto a : _subModels) {
         if (a->isRanges) {
-            for (auto & stand : a->strands) {
-                stand = ReverseRow(stand);
+            for (auto & strand : a->strands) {
+                strand = ReverseRow(strand);
             }
         }
     }
@@ -2998,7 +3879,7 @@ void SubModelsDialog::Reverse()
     TextCtrl_Name->SelectAll();
 }
 
-void SubModelsDialog::RemoveDuplicates()
+void SubModelsDialog::RemoveDuplicates(bool elide)
 {
     wxString name = GetSelectedName();
     if (name.empty()) {
@@ -3010,15 +3891,29 @@ void SubModelsDialog::RemoveDuplicates()
     int row = NodesGrid->GetGridCursorRow();
     wxString oldnodes = ExpandNodes(sm->strands[sm->strands.size() - 1 - row]);
 
-    auto oldNodeArrray = wxSplit(oldnodes, ',');
-    //remove duplicated
-    auto end = oldNodeArrray.end();
-    for (auto it = oldNodeArrray.begin(); it != end; ++it) {
-        end = std::remove(it + 1, end, *it);
+    auto oldNodeArray = wxSplit(oldnodes, ',');
+
+    if (elide) {
+        std::set<wxString> seen;
+        for (auto it = oldNodeArray.begin(); it != oldNodeArray.end(); ++it) {
+            if (it->empty() || *it == "0")
+                continue;
+            if (seen.count(*it)) {
+                *it = "";
+                continue;
+            }
+            seen.insert(*it);
+        }
+    } else {
+        // remove duplicated
+        auto end = oldNodeArray.end();
+        for (auto it = oldNodeArray.begin(); it != end; ++it) {
+            end = std::remove(it + 1, end, *it);
+        }
+        oldNodeArray.erase(end, oldNodeArray.end());
     }
-    oldNodeArrray.erase(end, oldNodeArrray.end());
 
-    sm->strands[sm->strands.size() - 1 - row] = CompressNodes(wxJoin(oldNodeArrray, ','));
+    sm->strands[sm->strands.size() - 1 - row] = CompressNodes(wxJoin(oldNodeArray, ','));
     Select(GetSelectedName());
 
     NodesGrid->SetGridCursor(row, 0);
@@ -3028,7 +3923,223 @@ void SubModelsDialog::RemoveDuplicates()
     ValidateWindow();
 }
 
-void SubModelsDialog::JoinSelectedModels()
+void SubModelsDialog::RemoveAllDuplicates(bool leftright, bool elide)
+{
+    wxString name = GetSelectedName();
+    if (name.empty()) {
+        return;
+    }
+
+    int row = NodesGrid->GetGridCursorRow();
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm)
+        return;
+
+    // Copy and expand data
+    std::vector<wxArrayString> data;
+    size_t mlen = 0;
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        data.push_back(wxSplit(ExpandNodes(sm->strands[sm->strands.size() - 1 - i]), ','));
+        mlen = std::max(mlen, data.back().size());
+    }
+
+    std::set<wxString> seen;
+    if (leftright) {
+        for (unsigned c = 0; c < mlen; ++c) {
+            for (unsigned r = 0; r < data.size(); ++r) {
+                if (data[r].size() <= c)
+                    continue; // Not applicable to row
+                if (data[r][c] == "" || data[r][c] == "0")
+                    continue;
+                if (seen.count(data[r][c])) {
+                    if (elide) {
+                        data[r][c] = "";
+                    } else {
+                        data[r][c] = "x"; // Deal with this later
+                    }
+                } else {
+                    seen.insert(data[r][c]);
+                }
+            }
+        }
+    } else {
+        for (unsigned r = 0; r < data.size(); ++r) {
+            for (unsigned c = 0; c < data[r].size(); ++c) {
+                if (data[r][c] == "" || data[r][c] == "0")
+                    continue;
+                if (seen.count(data[r][c])) {
+                    if (elide) {
+                        data[r][c] = "";
+                    } else {
+                        data[r][c] = "x"; // Deal with this later
+                    }
+                } else {
+                    seen.insert(data[r][c]);
+                }
+            }
+        }
+    
+    }
+
+    // Write back
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        for (auto it = data[i].begin(); it != data[i].end();) {
+            if (*it == "x") {
+                it = data[i].erase(it);
+            } else {
+                ++it;
+            }
+        }
+        sm->strands[sm->strands.size() - 1 - i] = CompressNodes(wxJoin(data[i], ','));
+    }
+
+    // Update UI
+    Select(GetSelectedName());
+
+    if (row >= 0) {
+        NodesGrid->SetGridCursor(row, 0);
+    }
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+}
+
+void SubModelsDialog::MakeRowsUniform()
+{
+    wxString name = GetSelectedName();
+    if (name.empty()) {
+        return;
+    }
+
+    int row = NodesGrid->GetGridCursorRow();
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm)
+        return;
+
+    // Copy and expand data
+    std::vector<wxArrayString> data;
+    size_t mlen = 0; // longest length of any row
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        data.push_back(wxSplit(ExpandNodes(sm->strands[sm->strands.size() - 1 - i]), ','));
+        mlen = std::max(mlen, data.back().size());
+    }
+
+    // Write back
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        wxArrayString ndata;
+
+        int dlt = 2 * (data[i].size());
+        int D = dlt - int(mlen);
+        int c = 0;
+        for (unsigned s = 0; s < mlen; ++s) {
+            if (D > 0) {
+                ndata.push_back(data[i][c]);
+                ++c;
+                D -= int(2 * mlen);
+            } else {
+                ndata.push_back("");
+            }
+            D += dlt;
+        }
+
+        sm->strands[sm->strands.size() - 1 - i] = CompressNodes(wxJoin(ndata, ','));
+    }
+
+    // Update UI
+    Select(GetSelectedName());
+
+    if (row >= 0) {
+        NodesGrid->SetGridCursor(row, 0);
+    }
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+}
+
+void SubModelsDialog::PivotRowsColumns()
+{
+    wxString name = GetSelectedName();
+    if (name.empty()) {
+        return;
+    }
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm)
+        return;
+
+    // Copy and expand data
+    std::vector<wxArrayString> data;
+    size_t mlen = 0; // max len
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        data.push_back(wxSplit(ExpandNodes(sm->strands[sm->strands.size() - 1 - i]), ','));
+        mlen = std::max(mlen, data.back().size());
+    }
+
+    // Build pivot model
+    std::vector<wxArrayString> ndata;
+    for (unsigned i = 0; i < mlen; ++i) {
+        ndata.push_back(wxArrayString());
+        for (size_t j = 0; j < data.size(); ++j) {
+            wxString s = "";
+            if (data[j].size() > i)
+                s = data[j][i];
+            ndata[i].push_back(s);
+        }
+    }
+
+    // Write back
+    sm->strands.clear();
+    for (int i = int(mlen-1); i >= 0; --i) {
+        sm->strands.push_back(CompressNodes(wxJoin(ndata[i], ',')));
+    }
+
+    // Update UI
+    Select(GetSelectedName());
+
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+}
+
+void SubModelsDialog::CombineStrands()
+{
+    wxString name = GetSelectedName();
+    if (name.empty()) {
+        return;
+    }
+
+    SubModelInfo* sm = GetSubModelInfo(name);
+    if (!sm)
+        return;
+
+    // Copy, expand, and concatenate data
+    wxString res = "";
+    for (unsigned i = 0; i < sm->strands.size(); ++i) {
+        if (i != 0) {
+            res += ",";
+        }
+        res += ExpandNodes(sm->strands[sm->strands.size() - 1 - i]);
+    }
+
+    // Write back
+    sm->strands.clear();
+    sm->strands.push_back(CompressNodes(res));
+
+    // Update UI
+    Select(GetSelectedName());
+
+    Panel3->SetFocus();
+    NodesGrid->SetFocus();
+
+    ValidateWindow();
+}
+
+void SubModelsDialog::JoinSelectedModels(bool singlestrand)
 {
     wxString name = GenerateSubModelName("SubModel-1");
 
@@ -3053,8 +4164,12 @@ void SubModelsDialog::JoinSelectedModels()
         }
         new_sm->vertical = old_sm->vertical;
 
-        for (auto const& stand : old_sm->strands) {
-            new_sm->strands.push_back(stand);
+        for (auto const& strand : old_sm->strands) {
+            if (!singlestrand || new_sm->strands.empty()) {
+                new_sm->strands.push_back(strand);
+            } else {
+                new_sm->strands[0] = new_sm->strands[0] + "," + strand; 
+            }
         }
     }
 
@@ -3070,6 +4185,52 @@ void SubModelsDialog::JoinSelectedModels()
     TextCtrl_Name->SelectAll();
 }
 
+void SubModelsDialog::SplitSelectedSubmodel()
+{
+    wxString names = GetSelectedNames();
+    wxStringTokenizer tokenizer(names, ",");
+
+    wxString name = "";
+    SubModelInfo* old_sm = nullptr;
+    while (tokenizer.HasMoreTokens()) {
+        wxString token = tokenizer.GetNextToken();
+        int index = GetSubModelInfoIndex(token);
+        if (index == -1) {
+            continue;
+        }
+        old_sm = _subModels.at(index);
+        if (old_sm == nullptr) {
+            continue;
+        }
+        if (!old_sm->isRanges) {
+            continue;
+        }
+        name = token;
+    }
+    if (name.empty())
+        return; // Something wrong, didn't get one submodel
+
+    int idx = 1;
+    for (auto const& strand : old_sm->strands) {
+        wxString newname = wxString::Format("%s-%02d", name, idx);
+        ++idx;
+        SubModelInfo* new_sm = new SubModelInfo(newname);
+        new_sm->isRanges = true;
+        new_sm->vertical = old_sm->vertical;
+        new_sm->strands.push_back(strand);
+        _subModels.push_back(new_sm);
+        long index = ListCtrl_SubModels->InsertItem(ListCtrl_SubModels->GetItemCount(), new_sm->name);
+        ListCtrl_SubModels->SetItemPtrData(index, (wxUIntPtr)new_sm);
+    }
+
+    ValidateWindow();
+    Select(name); // Keep old one selected... the other option would be seect all new ones
+
+    Panel3->SetFocus();
+    TextCtrl_Name->SetFocus();
+    TextCtrl_Name->SelectAll();
+}
+
 void SubModelsDialog::SortSubModelsByName()
 {
     std::sort(std::begin(_subModels), std::end(_subModels), [](SubModelInfo* a, SubModelInfo* b) {
diff --git a/xLights/SubModelsDialog.h b/xLights/SubModelsDialog.h
index f223f5cda..328065414 100644
--- a/xLights/SubModelsDialog.h
+++ b/xLights/SubModelsDialog.h
@@ -227,8 +227,25 @@ protected:
     static const long SUBMODEL_DIALOG_FLIP_VER;
     static const long SUBMODEL_DIALOG_REVERSE;
     static const long SUBMODEL_DIALOG_JOIN;
+    static const long SUBMODEL_DIALOG_JOIN_SS;
+    static const long SUBMODEL_DIALOG_SPLIT;
     static const long SUBMODEL_DIALOG_SORT_BY_NAME;
     static const long SUBMODEL_DIALOG_REMOVE_DUPLICATE;
+    static const long SUBMODEL_DIALOG_ELIDE_DUPLICATE;
+    static const long SUBMODEL_DIALOG_SORT_POINTS;
+    static const long SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_LR;
+    static const long SUBMODEL_DIALOG_REMOVE_ALL_DUPLICATE_TB;
+    static const long SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_LR;
+    static const long SUBMODEL_DIALOG_ELIDE_ALL_DUPLICATE_TB;
+    static const long SUBMODEL_DIALOG_EVEN_ROWS;
+    static const long SUBMODEL_DIALOG_PIVOT_ROWS_COLUMNS;
+    static const long SUBMODEL_DIALOG_SYMMETRIZE;
+    static const long SUBMODEL_DIALOG_SORT_POINTS_ALL;
+    static const long SUBMODEL_DIALOG_COMBINE_STRANDS;
+    static const long SUBMODEL_DIALOG_EXPAND_STRANDS_ALL;
+    static const long SUBMODEL_DIALOG_COMPRESS_STRANDS_ALL;
+    static const long SUBMODEL_DIALOG_BLANKS_AS_ZERO;
+    static const long SUBMODEL_DIALOG_BLANKS_AS_EMPTY;
 
     void SaveXML(Model* m);
     wxString GetSelectedName() const;
@@ -258,7 +275,12 @@ protected:
     void FlipHorizontal();
     void FlipVertical();
     void Reverse();
-    void RemoveDuplicates();
+    void RemoveDuplicates(bool elide);
+    void RemoveAllDuplicates(bool leftright, bool elide);
+    void MakeRowsUniform();
+    void PivotRowsColumns();
+    void CombineStrands();
+    void OrderPoints(bool wholemodel);
 
     void GenerateSegment(SubModelInfo* sm, int segments, int segment, bool horizontal, int count);
     void DisplayRange(const wxString &range);
@@ -275,8 +297,12 @@ protected:
     void ExportSubModelAsxModel(wxString const& filename, const std::string& name);
     void ExportSubmodelToOtherModels();
 
-    void JoinSelectedModels();
+    void JoinSelectedModels(bool singlestrand);
+    void SplitSelectedSubmodel();
     void SortSubModelsByName();
+    void Symmetrize();
+
+    void processAllStrands(wxString (*func)(wxString));
 
 private:
 
@@ -333,8 +359,8 @@ private:
 
     void RenderModel();
     void GetMouseLocation(int x, int y, glm::vec3& ray_origin, glm::vec3& ray_direction);
-    void SelectAllInBoundingRect(bool shiftdwn);
-    void RemoveNodes();
+    void SelectAllInBoundingRect(bool shiftdwn, bool cdwn);
+    void RemoveNodes(bool elide);
 
     void OnTextCtrl_NameText_KillFocus(wxFocusEvent& event);
     void OnSubbufferSize(wxSizeEvent& event);
diff --git a/xLights/UtilFunctions.cpp b/xLights/UtilFunctions.cpp
index b538794fc..7176a26ee 100644
--- a/xLights/UtilFunctions.cpp
+++ b/xLights/UtilFunctions.cpp
@@ -1481,7 +1481,7 @@ wxString CompressNodes(const wxString& nodes)
 
     for (const auto& i : as)
     {
-        if (i.empty()) {
+        if (i.empty() || i == "0") {
             // Flush out start/last if any
             if (start != -1) {
                 if (last != start) {
@@ -1491,7 +1491,7 @@ wxString CompressNodes(const wxString& nodes)
                 }
             }
             // Add empty and separator
-            res += ",";
+            res += i+",";
             start = last = -1;
             dir = 0;
             continue;
diff --git a/xLights/models/Model.cpp b/xLights/models/Model.cpp
index c40629773..c286bf669 100644
--- a/xLights/models/Model.cpp
+++ b/xLights/models/Model.cpp
@@ -5253,14 +5253,39 @@ void Model::DisplayModelOnWindow(ModelPreview* preview, xlGraphicsContext *ctx,
     }
 }
 
-wxString Model::GetNodeNear(ModelPreview* preview, wxPoint pt, bool flip)
+float Model::GetPreviewDimScale(ModelPreview* preview, int& w, int& h)
 {
-    int w, h;
     preview->GetSize(&w, &h);
     float scaleX = float(w) * 0.95 / GetModelScreenLocation().RenderWi;
     float scaleY = float(h) * 0.95 / GetModelScreenLocation().RenderHt;
     float scale = scaleY < scaleX ? scaleY : scaleX;
 
+    return scale;
+}
+
+void Model::GetScreenLocation(float& sx, float& sy, const NodeBaseClass::CoordStruct& it2, int w, int h, float scale)
+{
+    sx = it2.screenX;
+    sy = it2.screenY;
+
+    if (!GetModelScreenLocation().IsCenterBased()) {
+        sx -= GetModelScreenLocation().RenderWi / 2.0;
+        sy *= GetModelScreenLocation().GetVScaleFactor();
+        if (GetModelScreenLocation().GetVScaleFactor() < 0) {
+            sy += GetModelScreenLocation().RenderHt / 2.0;
+        } else {
+            sy -= GetModelScreenLocation().RenderHt / 2.0;
+        }
+    }
+    sy = ((sy * scale) + (h / 2));
+    sx = (sx * scale) + (w / 2);
+}
+
+wxString Model::GetNodeNear(ModelPreview* preview, wxPoint pt, bool flip)
+{
+    int w, h;
+    float scale = GetPreviewDimScale(preview, w, h);
+
     float pointScale = scale;
     if (pointScale > 2.5) {
         pointScale = 2.5;
@@ -5281,21 +5306,8 @@ wxString Model::GetNodeNear(ModelPreview* preview, wxPoint pt, bool flip)
     for (const auto& it : Nodes) {
         auto c = it.get()->Coords;
         for (const auto& it2 : c) {
-            float sx = it2.screenX;
-            float sy = it2.screenY;
-
-            if (!GetModelScreenLocation().IsCenterBased()) {
-                sx -= GetModelScreenLocation().RenderWi / 2.0;
-                sy *= GetModelScreenLocation().GetVScaleFactor();
-                if (GetModelScreenLocation().GetVScaleFactor() < 0) {
-                    sy += GetModelScreenLocation().RenderHt / 2.0;
-                }
-                else {
-                    sy -= GetModelScreenLocation().RenderHt / 2.0;
-                }
-            }
-            sy = ((sy * scale) + (h / 2));
-            sx = (sx * scale) + (w / 2);
+            float sx, sy;
+            GetScreenLocation(sx, sy, it2, w, h, scale);
 
             if (sx >= (px - pointScale) && sx <= (px + pointScale) &&
                 sy >= (py - pointScale) && sy <= (py + pointScale)) {
@@ -5307,13 +5319,30 @@ wxString Model::GetNodeNear(ModelPreview* preview, wxPoint pt, bool flip)
     return "";
 }
 
+bool Model::GetScreenLocations(ModelPreview* preview, std::map<int, std::pair<float, float>>& coords)
+{
+    int w, h;
+    float scale = GetPreviewDimScale(preview, w, h);
+
+    int i = 1;
+    for (const auto& it : Nodes) {
+        auto c = it.get()->Coords;
+        if (c.size() != 1)
+            return false;
+        for (const auto& it2 : c) {
+            float sx, sy;
+            GetScreenLocation(sx, sy, it2, w, h, scale);
+            coords[i] = std::make_pair(sx, sy);
+        }
+        ++i;
+    }
+    return true;
+}
+
 std::vector<int> Model::GetNodesInBoundingBox(ModelPreview* preview, wxPoint start, wxPoint end)
 {
     int w, h;
-    preview->GetSize(&w, &h);
-    float scaleX = float(w) * 0.95 / GetModelScreenLocation().RenderWi;
-    float scaleY = float(h) * 0.95 / GetModelScreenLocation().RenderHt;
-    float scale = scaleY < scaleX ? scaleY : scaleX;
+    float scale = GetPreviewDimScale(preview, w, h);
 
     std::vector<int> nodes;
 
@@ -5338,24 +5367,12 @@ std::vector<int> Model::GetNodesInBoundingBox(ModelPreview* preview, wxPoint sta
     for (const auto& it : Nodes) {
         auto c = it.get()->Coords;
         for (const auto& it2 : c) {
-            float sx = it2.screenX;
-            float sy = it2.screenY;
-
-            if (!GetModelScreenLocation().IsCenterBased()) {
-                sx -= GetModelScreenLocation().RenderWi / 2.0;
-                sy *= GetModelScreenLocation().GetVScaleFactor();
-                if (GetModelScreenLocation().GetVScaleFactor() < 0) {
-                    sy += GetModelScreenLocation().RenderHt / 2.0;
-                }
-                else {
-                    sy -= GetModelScreenLocation().RenderHt / 2.0;
-                }
-            }
-            sy = ((sy * scale) + (h / 2));
-            sx = (sx * scale) + (w / 2);
+            float sx, sy;
+            GetScreenLocation(sx, sy, it2, w, h, scale);
 
             if (sx >= startpx && sx <= endpx &&
-                sy >= startpy && sy <= endpy) {
+                sy >= startpy && sy <= endpy)
+            {
                 nodes.push_back(i);
             }
         }
@@ -5394,7 +5411,7 @@ void Model::DisplayEffectOnWindow(ModelPreview* preview, double pointSize)
         }
 
         int w, h;
-        preview->GetSize(&w, &h);
+        float scale = GetPreviewDimScale(preview, w, h);
 
         size_t NodeCount = Nodes.size();
         bool created = false;
@@ -5402,9 +5419,6 @@ void Model::DisplayEffectOnWindow(ModelPreview* preview, double pointSize)
         int renderWi = GetModelScreenLocation().RenderWi;
         int renderHi = GetModelScreenLocation().RenderHt;
 
-        float scaleX = float(w) * 0.95 / GetModelScreenLocation().RenderWi;
-        float scaleY = float(h) * 0.95 / GetModelScreenLocation().RenderHt;
-        float scale = scaleY < scaleX ? scaleY : scaleX;
         float ml, mb;
         GetMinScreenXY(ml, mb);
         ml += GetModelScreenLocation().RenderWi / 2;
@@ -5502,7 +5516,8 @@ void Model::DisplayEffectOnWindow(ModelPreview* preview, double pointSize)
                         if (cache->vica->getCount() && (lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_SQUARE ||
                                                         lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_SMOOTH ||
                                                         Nodes[n]->model->_pixelStyle == PIXEL_STYLE::PIXEL_STYLE_SQUARE ||
-                                                        Nodes[n]->model->_pixelStyle == PIXEL_STYLE::PIXEL_STYLE_SMOOTH)) {
+                                                        Nodes[n]->model->_pixelStyle == PIXEL_STYLE::PIXEL_STYLE_SMOOTH))
+                        {
                             int count = cache->vica->getCount();
                             cache->program->addStep([=](xlGraphicsContext* ctx) {
                                 if (lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_SOLID_CIRCLE || lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_BLENDED_CIRCLE) {
@@ -5531,7 +5546,7 @@ void Model::DisplayEffectOnWindow(ModelPreview* preview, double pointSize)
                     }
                 }
             }
-            if (cache->vica->getCount() > startVertex) {
+            if (int(cache->vica->getCount()) > startVertex) {
                 int count = cache->vica->getCount();
                 cache->program->addStep([=](xlGraphicsContext* ctx) {
                     if (lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_SOLID_CIRCLE || lastPixelStyle == PIXEL_STYLE::PIXEL_STYLE_BLENDED_CIRCLE) {
diff --git a/xLights/models/Model.h b/xLights/models/Model.h
index 0d38f723c..ed9a64d17 100644
--- a/xLights/models/Model.h
+++ b/xLights/models/Model.h
@@ -416,6 +416,9 @@ public:
 
 
     virtual int NodeRenderOrder() { return 0; }
+    float GetPreviewDimScale(ModelPreview* preview, int& w, int& h);
+    void GetScreenLocation(float& sx, float& sy, const NodeBaseClass::CoordStruct& it2, int w, int h, float scale);
+    bool GetScreenLocations(ModelPreview *preview, std::map<int, std::pair<float, float>>& coords);
     wxString GetNodeNear(ModelPreview* preview, wxPoint pt, bool flip);
     std::vector<int> GetNodesInBoundingBox(ModelPreview* preview, wxPoint start, wxPoint end);
     bool IsMultiCoordsPerNode() const;
